import {
  __commonJS
} from "./chunk-JVWSFFO4.js";

// node_modules/@tabler/core/dist/js/tabler.min.js
var require_tabler_min = __commonJS({
  "node_modules/@tabler/core/dist/js/tabler.min.js"(exports, module) {
    !(function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).tabler = {});
    })(exports, function(t) {
      "use strict";
      const e = document.querySelectorAll('[data-bs-toggle="autosize"]');
      e.length && e.forEach(function(t2) {
        window.autosize && window.autosize(t2);
      });
      const i = document.querySelectorAll("[data-countup]");
      i.length && i.forEach(function(t2) {
        let e2 = {};
        try {
          const i3 = t2.getAttribute("data-countup") ? JSON.parse(t2.getAttribute("data-countup")) : {};
          e2 = Object.assign({ enableScrollSpy: true }, i3);
        } catch (t3) {
        }
        const i2 = parseInt(t2.innerHTML, 10);
        if (window.countUp && window.countUp.CountUp) {
          const n2 = new window.countUp.CountUp(t2, i2, e2);
          n2.error || n2.start();
        }
      }), [].slice.call(document.querySelectorAll("[data-mask]")).map(function(t2) {
        window.IMask && new window.IMask(t2, { mask: t2.dataset.mask, lazy: "true" === t2.dataset["mask-visible"] });
      });
      var n = "top", s = "bottom", o = "right", r = "left", a = "auto", l = [n, s, o, r], c = "start", h = "end", u = "clippingParents", d = "viewport", f = "popper", p = "reference", m = l.reduce(function(t2, e2) {
        return t2.concat([e2 + "-" + c, e2 + "-" + h]);
      }, []), g = [].concat(l, [a]).reduce(function(t2, e2) {
        return t2.concat([e2, e2 + "-" + c, e2 + "-" + h]);
      }, []), _ = "beforeRead", b = "read", v = "afterRead", y = "beforeMain", w = "main", A = "afterMain", E = "beforeWrite", T = "write", C = "afterWrite", O = [_, b, v, y, w, A, E, T, C];
      function x(t2) {
        return t2 ? (t2.nodeName || "").toLowerCase() : null;
      }
      function k(t2) {
        if (null == t2) return window;
        if ("[object Window]" !== t2.toString()) {
          var e2 = t2.ownerDocument;
          return e2 && e2.defaultView || window;
        }
        return t2;
      }
      function S(t2) {
        return t2 instanceof k(t2).Element || t2 instanceof Element;
      }
      function L(t2) {
        return t2 instanceof k(t2).HTMLElement || t2 instanceof HTMLElement;
      }
      function $(t2) {
        return "undefined" != typeof ShadowRoot && (t2 instanceof k(t2).ShadowRoot || t2 instanceof ShadowRoot);
      }
      const D = { name: "applyStyles", enabled: true, phase: "write", fn: function(t2) {
        var e2 = t2.state;
        Object.keys(e2.elements).forEach(function(t3) {
          var i2 = e2.styles[t3] || {}, n2 = e2.attributes[t3] || {}, s2 = e2.elements[t3];
          L(s2) && x(s2) && (Object.assign(s2.style, i2), Object.keys(n2).forEach(function(t4) {
            var e3 = n2[t4];
            false === e3 ? s2.removeAttribute(t4) : s2.setAttribute(t4, true === e3 ? "" : e3);
          }));
        });
      }, effect: function(t2) {
        var e2 = t2.state, i2 = { popper: { position: e2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e2.elements.popper.style, i2.popper), e2.styles = i2, e2.elements.arrow && Object.assign(e2.elements.arrow.style, i2.arrow), function() {
          Object.keys(e2.elements).forEach(function(t3) {
            var n2 = e2.elements[t3], s2 = e2.attributes[t3] || {}, o2 = Object.keys(e2.styles.hasOwnProperty(t3) ? e2.styles[t3] : i2[t3]).reduce(function(t4, e3) {
              return t4[e3] = "", t4;
            }, {});
            L(n2) && x(n2) && (Object.assign(n2.style, o2), Object.keys(s2).forEach(function(t4) {
              n2.removeAttribute(t4);
            }));
          });
        };
      }, requires: ["computeStyles"] };
      function I(t2) {
        return t2.split("-")[0];
      }
      var P = Math.max, N = Math.min, M = Math.round;
      function j() {
        var t2 = navigator.userAgentData;
        return null != t2 && t2.brands && Array.isArray(t2.brands) ? t2.brands.map(function(t3) {
          return t3.brand + "/" + t3.version;
        }).join(" ") : navigator.userAgent;
      }
      function F() {
        return !/^((?!chrome|android).)*safari/i.test(j());
      }
      function H(t2, e2, i2) {
        void 0 === e2 && (e2 = false), void 0 === i2 && (i2 = false);
        var n2 = t2.getBoundingClientRect(), s2 = 1, o2 = 1;
        e2 && L(t2) && (s2 = t2.offsetWidth > 0 && M(n2.width) / t2.offsetWidth || 1, o2 = t2.offsetHeight > 0 && M(n2.height) / t2.offsetHeight || 1);
        var r2 = (S(t2) ? k(t2) : window).visualViewport, a2 = !F() && i2, l2 = (n2.left + (a2 && r2 ? r2.offsetLeft : 0)) / s2, c2 = (n2.top + (a2 && r2 ? r2.offsetTop : 0)) / o2, h2 = n2.width / s2, u2 = n2.height / o2;
        return { width: h2, height: u2, top: c2, right: l2 + h2, bottom: c2 + u2, left: l2, x: l2, y: c2 };
      }
      function z(t2) {
        var e2 = H(t2), i2 = t2.offsetWidth, n2 = t2.offsetHeight;
        return Math.abs(e2.width - i2) <= 1 && (i2 = e2.width), Math.abs(e2.height - n2) <= 1 && (n2 = e2.height), { x: t2.offsetLeft, y: t2.offsetTop, width: i2, height: n2 };
      }
      function B(t2, e2) {
        var i2 = e2.getRootNode && e2.getRootNode();
        if (t2.contains(e2)) return true;
        if (i2 && $(i2)) {
          var n2 = e2;
          do {
            if (n2 && t2.isSameNode(n2)) return true;
            n2 = n2.parentNode || n2.host;
          } while (n2);
        }
        return false;
      }
      function W(t2) {
        return k(t2).getComputedStyle(t2);
      }
      function q(t2) {
        return ["table", "td", "th"].indexOf(x(t2)) >= 0;
      }
      function R(t2) {
        return ((S(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
      }
      function V(t2) {
        return "html" === x(t2) ? t2 : t2.assignedSlot || t2.parentNode || ($(t2) ? t2.host : null) || R(t2);
      }
      function U(t2) {
        return L(t2) && "fixed" !== W(t2).position ? t2.offsetParent : null;
      }
      function K(t2) {
        for (var e2 = k(t2), i2 = U(t2); i2 && q(i2) && "static" === W(i2).position; ) i2 = U(i2);
        return i2 && ("html" === x(i2) || "body" === x(i2) && "static" === W(i2).position) ? e2 : i2 || (function(t3) {
          var e3 = /firefox/i.test(j());
          if (/Trident/i.test(j()) && L(t3) && "fixed" === W(t3).position) return null;
          var i3 = V(t3);
          for ($(i3) && (i3 = i3.host); L(i3) && ["html", "body"].indexOf(x(i3)) < 0; ) {
            var n2 = W(i3);
            if ("none" !== n2.transform || "none" !== n2.perspective || "paint" === n2.contain || -1 !== ["transform", "perspective"].indexOf(n2.willChange) || e3 && "filter" === n2.willChange || e3 && n2.filter && "none" !== n2.filter) return i3;
            i3 = i3.parentNode;
          }
          return null;
        })(t2) || e2;
      }
      function Q(t2) {
        return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
      }
      function X(t2, e2, i2) {
        return P(t2, N(e2, i2));
      }
      function Y(t2) {
        return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t2);
      }
      function G(t2, e2) {
        return e2.reduce(function(e3, i2) {
          return e3[i2] = t2, e3;
        }, {});
      }
      const J = { name: "arrow", enabled: true, phase: "main", fn: function(t2) {
        var e2, i2 = t2.state, a2 = t2.name, c2 = t2.options, h2 = i2.elements.arrow, u2 = i2.modifiersData.popperOffsets, d2 = I(i2.placement), f2 = Q(d2), p2 = [r, o].indexOf(d2) >= 0 ? "height" : "width";
        if (h2 && u2) {
          var m2 = (function(t3, e3) {
            return Y("number" != typeof (t3 = "function" == typeof t3 ? t3(Object.assign({}, e3.rects, { placement: e3.placement })) : t3) ? t3 : G(t3, l));
          })(c2.padding, i2), g2 = z(h2), _2 = "y" === f2 ? n : r, b2 = "y" === f2 ? s : o, v2 = i2.rects.reference[p2] + i2.rects.reference[f2] - u2[f2] - i2.rects.popper[p2], y2 = u2[f2] - i2.rects.reference[f2], w2 = K(h2), A2 = w2 ? "y" === f2 ? w2.clientHeight || 0 : w2.clientWidth || 0 : 0, E2 = v2 / 2 - y2 / 2, T2 = m2[_2], C2 = A2 - g2[p2] - m2[b2], O2 = A2 / 2 - g2[p2] / 2 + E2, x2 = X(T2, O2, C2), k2 = f2;
          i2.modifiersData[a2] = ((e2 = {})[k2] = x2, e2.centerOffset = x2 - O2, e2);
        }
      }, effect: function(t2) {
        var e2 = t2.state, i2 = t2.options.element, n2 = void 0 === i2 ? "[data-popper-arrow]" : i2;
        null != n2 && ("string" != typeof n2 || (n2 = e2.elements.popper.querySelector(n2))) && B(e2.elements.popper, n2) && (e2.elements.arrow = n2);
      }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function Z(t2) {
        return t2.split("-")[1];
      }
      var tt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function et(t2) {
        var e2, i2 = t2.popper, a2 = t2.popperRect, l2 = t2.placement, c2 = t2.variation, u2 = t2.offsets, d2 = t2.position, f2 = t2.gpuAcceleration, p2 = t2.adaptive, m2 = t2.roundOffsets, g2 = t2.isFixed, _2 = u2.x, b2 = void 0 === _2 ? 0 : _2, v2 = u2.y, y2 = void 0 === v2 ? 0 : v2, w2 = "function" == typeof m2 ? m2({ x: b2, y: y2 }) : { x: b2, y: y2 };
        b2 = w2.x, y2 = w2.y;
        var A2 = u2.hasOwnProperty("x"), E2 = u2.hasOwnProperty("y"), T2 = r, C2 = n, O2 = window;
        if (p2) {
          var x2 = K(i2), S2 = "clientHeight", L2 = "clientWidth";
          x2 === k(i2) && "static" !== W(x2 = R(i2)).position && "absolute" === d2 && (S2 = "scrollHeight", L2 = "scrollWidth"), (l2 === n || (l2 === r || l2 === o) && c2 === h) && (C2 = s, y2 -= (g2 && x2 === O2 && O2.visualViewport ? O2.visualViewport.height : x2[S2]) - a2.height, y2 *= f2 ? 1 : -1), l2 !== r && (l2 !== n && l2 !== s || c2 !== h) || (T2 = o, b2 -= (g2 && x2 === O2 && O2.visualViewport ? O2.visualViewport.width : x2[L2]) - a2.width, b2 *= f2 ? 1 : -1);
        }
        var $2, D2 = Object.assign({ position: d2 }, p2 && tt), I2 = true === m2 ? (function(t3, e3) {
          var i3 = t3.x, n2 = t3.y, s2 = e3.devicePixelRatio || 1;
          return { x: M(i3 * s2) / s2 || 0, y: M(n2 * s2) / s2 || 0 };
        })({ x: b2, y: y2 }, k(i2)) : { x: b2, y: y2 };
        return b2 = I2.x, y2 = I2.y, f2 ? Object.assign({}, D2, (($2 = {})[C2] = E2 ? "0" : "", $2[T2] = A2 ? "0" : "", $2.transform = (O2.devicePixelRatio || 1) <= 1 ? "translate(" + b2 + "px, " + y2 + "px)" : "translate3d(" + b2 + "px, " + y2 + "px, 0)", $2)) : Object.assign({}, D2, ((e2 = {})[C2] = E2 ? y2 + "px" : "", e2[T2] = A2 ? b2 + "px" : "", e2.transform = "", e2));
      }
      const it = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: function(t2) {
        var e2 = t2.state, i2 = t2.options, n2 = i2.gpuAcceleration, s2 = void 0 === n2 || n2, o2 = i2.adaptive, r2 = void 0 === o2 || o2, a2 = i2.roundOffsets, l2 = void 0 === a2 || a2, c2 = { placement: I(e2.placement), variation: Z(e2.placement), popper: e2.elements.popper, popperRect: e2.rects.popper, gpuAcceleration: s2, isFixed: "fixed" === e2.options.strategy };
        null != e2.modifiersData.popperOffsets && (e2.styles.popper = Object.assign({}, e2.styles.popper, et(Object.assign({}, c2, { offsets: e2.modifiersData.popperOffsets, position: e2.options.strategy, adaptive: r2, roundOffsets: l2 })))), null != e2.modifiersData.arrow && (e2.styles.arrow = Object.assign({}, e2.styles.arrow, et(Object.assign({}, c2, { offsets: e2.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: l2 })))), e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-placement": e2.placement });
      }, data: {} };
      var nt = { passive: true };
      const st = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: function(t2) {
        var e2 = t2.state, i2 = t2.instance, n2 = t2.options, s2 = n2.scroll, o2 = void 0 === s2 || s2, r2 = n2.resize, a2 = void 0 === r2 || r2, l2 = k(e2.elements.popper), c2 = [].concat(e2.scrollParents.reference, e2.scrollParents.popper);
        return o2 && c2.forEach(function(t3) {
          t3.addEventListener("scroll", i2.update, nt);
        }), a2 && l2.addEventListener("resize", i2.update, nt), function() {
          o2 && c2.forEach(function(t3) {
            t3.removeEventListener("scroll", i2.update, nt);
          }), a2 && l2.removeEventListener("resize", i2.update, nt);
        };
      }, data: {} };
      var ot = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function rt(t2) {
        return t2.replace(/left|right|bottom|top/g, function(t3) {
          return ot[t3];
        });
      }
      var at = { start: "end", end: "start" };
      function lt(t2) {
        return t2.replace(/start|end/g, function(t3) {
          return at[t3];
        });
      }
      function ct(t2) {
        var e2 = k(t2);
        return { scrollLeft: e2.pageXOffset, scrollTop: e2.pageYOffset };
      }
      function ht(t2) {
        return H(R(t2)).left + ct(t2).scrollLeft;
      }
      function ut(t2) {
        var e2 = W(t2), i2 = e2.overflow, n2 = e2.overflowX, s2 = e2.overflowY;
        return /auto|scroll|overlay|hidden/.test(i2 + s2 + n2);
      }
      function dt(t2) {
        return ["html", "body", "#document"].indexOf(x(t2)) >= 0 ? t2.ownerDocument.body : L(t2) && ut(t2) ? t2 : dt(V(t2));
      }
      function ft(t2, e2) {
        var i2;
        void 0 === e2 && (e2 = []);
        var n2 = dt(t2), s2 = n2 === (null == (i2 = t2.ownerDocument) ? void 0 : i2.body), o2 = k(n2), r2 = s2 ? [o2].concat(o2.visualViewport || [], ut(n2) ? n2 : []) : n2, a2 = e2.concat(r2);
        return s2 ? a2 : a2.concat(ft(V(r2)));
      }
      function pt(t2) {
        return Object.assign({}, t2, { left: t2.x, top: t2.y, right: t2.x + t2.width, bottom: t2.y + t2.height });
      }
      function mt(t2, e2, i2) {
        return e2 === d ? pt((function(t3, e3) {
          var i3 = k(t3), n2 = R(t3), s2 = i3.visualViewport, o2 = n2.clientWidth, r2 = n2.clientHeight, a2 = 0, l2 = 0;
          if (s2) {
            o2 = s2.width, r2 = s2.height;
            var c2 = F();
            (c2 || !c2 && "fixed" === e3) && (a2 = s2.offsetLeft, l2 = s2.offsetTop);
          }
          return { width: o2, height: r2, x: a2 + ht(t3), y: l2 };
        })(t2, i2)) : S(e2) ? (function(t3, e3) {
          var i3 = H(t3, false, "fixed" === e3);
          return i3.top = i3.top + t3.clientTop, i3.left = i3.left + t3.clientLeft, i3.bottom = i3.top + t3.clientHeight, i3.right = i3.left + t3.clientWidth, i3.width = t3.clientWidth, i3.height = t3.clientHeight, i3.x = i3.left, i3.y = i3.top, i3;
        })(e2, i2) : pt((function(t3) {
          var e3, i3 = R(t3), n2 = ct(t3), s2 = null == (e3 = t3.ownerDocument) ? void 0 : e3.body, o2 = P(i3.scrollWidth, i3.clientWidth, s2 ? s2.scrollWidth : 0, s2 ? s2.clientWidth : 0), r2 = P(i3.scrollHeight, i3.clientHeight, s2 ? s2.scrollHeight : 0, s2 ? s2.clientHeight : 0), a2 = -n2.scrollLeft + ht(t3), l2 = -n2.scrollTop;
          return "rtl" === W(s2 || i3).direction && (a2 += P(i3.clientWidth, s2 ? s2.clientWidth : 0) - o2), { width: o2, height: r2, x: a2, y: l2 };
        })(R(t2)));
      }
      function gt(t2) {
        var e2, i2 = t2.reference, a2 = t2.element, l2 = t2.placement, u2 = l2 ? I(l2) : null, d2 = l2 ? Z(l2) : null, f2 = i2.x + i2.width / 2 - a2.width / 2, p2 = i2.y + i2.height / 2 - a2.height / 2;
        switch (u2) {
          case n:
            e2 = { x: f2, y: i2.y - a2.height };
            break;
          case s:
            e2 = { x: f2, y: i2.y + i2.height };
            break;
          case o:
            e2 = { x: i2.x + i2.width, y: p2 };
            break;
          case r:
            e2 = { x: i2.x - a2.width, y: p2 };
            break;
          default:
            e2 = { x: i2.x, y: i2.y };
        }
        var m2 = u2 ? Q(u2) : null;
        if (null != m2) {
          var g2 = "y" === m2 ? "height" : "width";
          switch (d2) {
            case c:
              e2[m2] = e2[m2] - (i2[g2] / 2 - a2[g2] / 2);
              break;
            case h:
              e2[m2] = e2[m2] + (i2[g2] / 2 - a2[g2] / 2);
          }
        }
        return e2;
      }
      function _t(t2, e2) {
        void 0 === e2 && (e2 = {});
        var i2 = e2, r2 = i2.placement, a2 = void 0 === r2 ? t2.placement : r2, c2 = i2.strategy, h2 = void 0 === c2 ? t2.strategy : c2, m2 = i2.boundary, g2 = void 0 === m2 ? u : m2, _2 = i2.rootBoundary, b2 = void 0 === _2 ? d : _2, v2 = i2.elementContext, y2 = void 0 === v2 ? f : v2, w2 = i2.altBoundary, A2 = void 0 !== w2 && w2, E2 = i2.padding, T2 = void 0 === E2 ? 0 : E2, C2 = Y("number" != typeof T2 ? T2 : G(T2, l)), O2 = y2 === f ? p : f, k2 = t2.rects.popper, $2 = t2.elements[A2 ? O2 : y2], D2 = (function(t3, e3, i3, n2) {
          var s2 = "clippingParents" === e3 ? (function(t4) {
            var e4 = ft(V(t4)), i4 = ["absolute", "fixed"].indexOf(W(t4).position) >= 0 && L(t4) ? K(t4) : t4;
            return S(i4) ? e4.filter(function(t5) {
              return S(t5) && B(t5, i4) && "body" !== x(t5);
            }) : [];
          })(t3) : [].concat(e3), o2 = [].concat(s2, [i3]), r3 = o2[0], a3 = o2.reduce(function(e4, i4) {
            var s3 = mt(t3, i4, n2);
            return e4.top = P(s3.top, e4.top), e4.right = N(s3.right, e4.right), e4.bottom = N(s3.bottom, e4.bottom), e4.left = P(s3.left, e4.left), e4;
          }, mt(t3, r3, n2));
          return a3.width = a3.right - a3.left, a3.height = a3.bottom - a3.top, a3.x = a3.left, a3.y = a3.top, a3;
        })(S($2) ? $2 : $2.contextElement || R(t2.elements.popper), g2, b2, h2), I2 = H(t2.elements.reference), M2 = gt({ reference: I2, element: k2, placement: a2 }), j2 = pt(Object.assign({}, k2, M2)), F2 = y2 === f ? j2 : I2, z2 = { top: D2.top - F2.top + C2.top, bottom: F2.bottom - D2.bottom + C2.bottom, left: D2.left - F2.left + C2.left, right: F2.right - D2.right + C2.right }, q2 = t2.modifiersData.offset;
        if (y2 === f && q2) {
          var U2 = q2[a2];
          Object.keys(z2).forEach(function(t3) {
            var e3 = [o, s].indexOf(t3) >= 0 ? 1 : -1, i3 = [n, s].indexOf(t3) >= 0 ? "y" : "x";
            z2[t3] += U2[i3] * e3;
          });
        }
        return z2;
      }
      function bt(t2, e2) {
        void 0 === e2 && (e2 = {});
        var i2 = e2, n2 = i2.placement, s2 = i2.boundary, o2 = i2.rootBoundary, r2 = i2.padding, a2 = i2.flipVariations, c2 = i2.allowedAutoPlacements, h2 = void 0 === c2 ? g : c2, u2 = Z(n2), d2 = u2 ? a2 ? m : m.filter(function(t3) {
          return Z(t3) === u2;
        }) : l, f2 = d2.filter(function(t3) {
          return h2.indexOf(t3) >= 0;
        });
        0 === f2.length && (f2 = d2);
        var p2 = f2.reduce(function(e3, i3) {
          return e3[i3] = _t(t2, { placement: i3, boundary: s2, rootBoundary: o2, padding: r2 })[I(i3)], e3;
        }, {});
        return Object.keys(p2).sort(function(t3, e3) {
          return p2[t3] - p2[e3];
        });
      }
      const vt = { name: "flip", enabled: true, phase: "main", fn: function(t2) {
        var e2 = t2.state, i2 = t2.options, l2 = t2.name;
        if (!e2.modifiersData[l2]._skip) {
          for (var h2 = i2.mainAxis, u2 = void 0 === h2 || h2, d2 = i2.altAxis, f2 = void 0 === d2 || d2, p2 = i2.fallbackPlacements, m2 = i2.padding, g2 = i2.boundary, _2 = i2.rootBoundary, b2 = i2.altBoundary, v2 = i2.flipVariations, y2 = void 0 === v2 || v2, w2 = i2.allowedAutoPlacements, A2 = e2.options.placement, E2 = I(A2), T2 = p2 || (E2 !== A2 && y2 ? (function(t3) {
            if (I(t3) === a) return [];
            var e3 = rt(t3);
            return [lt(t3), e3, lt(e3)];
          })(A2) : [rt(A2)]), C2 = [A2].concat(T2).reduce(function(t3, i3) {
            return t3.concat(I(i3) === a ? bt(e2, { placement: i3, boundary: g2, rootBoundary: _2, padding: m2, flipVariations: y2, allowedAutoPlacements: w2 }) : i3);
          }, []), O2 = e2.rects.reference, x2 = e2.rects.popper, k2 = /* @__PURE__ */ new Map(), S2 = true, L2 = C2[0], $2 = 0; $2 < C2.length; $2++) {
            var D2 = C2[$2], P2 = I(D2), N2 = Z(D2) === c, M2 = [n, s].indexOf(P2) >= 0, j2 = M2 ? "width" : "height", F2 = _t(e2, { placement: D2, boundary: g2, rootBoundary: _2, altBoundary: b2, padding: m2 }), H2 = M2 ? N2 ? o : r : N2 ? s : n;
            O2[j2] > x2[j2] && (H2 = rt(H2));
            var z2 = rt(H2), B2 = [];
            if (u2 && B2.push(F2[P2] <= 0), f2 && B2.push(F2[H2] <= 0, F2[z2] <= 0), B2.every(function(t3) {
              return t3;
            })) {
              L2 = D2, S2 = false;
              break;
            }
            k2.set(D2, B2);
          }
          if (S2) for (var W2 = function(t3) {
            var e3 = C2.find(function(e4) {
              var i3 = k2.get(e4);
              if (i3) return i3.slice(0, t3).every(function(t4) {
                return t4;
              });
            });
            if (e3) return L2 = e3, "break";
          }, q2 = y2 ? 3 : 1; q2 > 0 && "break" !== W2(q2); q2--) ;
          e2.placement !== L2 && (e2.modifiersData[l2]._skip = true, e2.placement = L2, e2.reset = true);
        }
      }, requiresIfExists: ["offset"], data: { _skip: false } };
      function yt(t2, e2, i2) {
        return void 0 === i2 && (i2 = { x: 0, y: 0 }), { top: t2.top - e2.height - i2.y, right: t2.right - e2.width + i2.x, bottom: t2.bottom - e2.height + i2.y, left: t2.left - e2.width - i2.x };
      }
      function wt(t2) {
        return [n, o, s, r].some(function(e2) {
          return t2[e2] >= 0;
        });
      }
      const At = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: function(t2) {
        var e2 = t2.state, i2 = t2.name, n2 = e2.rects.reference, s2 = e2.rects.popper, o2 = e2.modifiersData.preventOverflow, r2 = _t(e2, { elementContext: "reference" }), a2 = _t(e2, { altBoundary: true }), l2 = yt(r2, n2), c2 = yt(a2, s2, o2), h2 = wt(l2), u2 = wt(c2);
        e2.modifiersData[i2] = { referenceClippingOffsets: l2, popperEscapeOffsets: c2, isReferenceHidden: h2, hasPopperEscaped: u2 }, e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-reference-hidden": h2, "data-popper-escaped": u2 });
      } }, Et = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: function(t2) {
        var e2 = t2.state, i2 = t2.options, s2 = t2.name, a2 = i2.offset, l2 = void 0 === a2 ? [0, 0] : a2, c2 = g.reduce(function(t3, i3) {
          return t3[i3] = (function(t4, e3, i4) {
            var s3 = I(t4), a3 = [r, n].indexOf(s3) >= 0 ? -1 : 1, l3 = "function" == typeof i4 ? i4(Object.assign({}, e3, { placement: t4 })) : i4, c3 = l3[0], h3 = l3[1];
            return c3 = c3 || 0, h3 = (h3 || 0) * a3, [r, o].indexOf(s3) >= 0 ? { x: h3, y: c3 } : { x: c3, y: h3 };
          })(i3, e2.rects, l2), t3;
        }, {}), h2 = c2[e2.placement], u2 = h2.x, d2 = h2.y;
        null != e2.modifiersData.popperOffsets && (e2.modifiersData.popperOffsets.x += u2, e2.modifiersData.popperOffsets.y += d2), e2.modifiersData[s2] = c2;
      } }, Tt = { name: "popperOffsets", enabled: true, phase: "read", fn: function(t2) {
        var e2 = t2.state, i2 = t2.name;
        e2.modifiersData[i2] = gt({ reference: e2.rects.reference, element: e2.rects.popper, placement: e2.placement });
      }, data: {} }, Ct = { name: "preventOverflow", enabled: true, phase: "main", fn: function(t2) {
        var e2 = t2.state, i2 = t2.options, a2 = t2.name, l2 = i2.mainAxis, h2 = void 0 === l2 || l2, u2 = i2.altAxis, d2 = void 0 !== u2 && u2, f2 = i2.boundary, p2 = i2.rootBoundary, m2 = i2.altBoundary, g2 = i2.padding, _2 = i2.tether, b2 = void 0 === _2 || _2, v2 = i2.tetherOffset, y2 = void 0 === v2 ? 0 : v2, w2 = _t(e2, { boundary: f2, rootBoundary: p2, padding: g2, altBoundary: m2 }), A2 = I(e2.placement), E2 = Z(e2.placement), T2 = !E2, C2 = Q(A2), O2 = "x" === C2 ? "y" : "x", x2 = e2.modifiersData.popperOffsets, k2 = e2.rects.reference, S2 = e2.rects.popper, L2 = "function" == typeof y2 ? y2(Object.assign({}, e2.rects, { placement: e2.placement })) : y2, $2 = "number" == typeof L2 ? { mainAxis: L2, altAxis: L2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, L2), D2 = e2.modifiersData.offset ? e2.modifiersData.offset[e2.placement] : null, M2 = { x: 0, y: 0 };
        if (x2) {
          if (h2) {
            var j2, F2 = "y" === C2 ? n : r, H2 = "y" === C2 ? s : o, B2 = "y" === C2 ? "height" : "width", W2 = x2[C2], q2 = W2 + w2[F2], R2 = W2 - w2[H2], V2 = b2 ? -S2[B2] / 2 : 0, U2 = E2 === c ? k2[B2] : S2[B2], Y2 = E2 === c ? -S2[B2] : -k2[B2], G2 = e2.elements.arrow, J2 = b2 && G2 ? z(G2) : { width: 0, height: 0 }, tt2 = e2.modifiersData["arrow#persistent"] ? e2.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, et2 = tt2[F2], it2 = tt2[H2], nt2 = X(0, k2[B2], J2[B2]), st2 = T2 ? k2[B2] / 2 - V2 - nt2 - et2 - $2.mainAxis : U2 - nt2 - et2 - $2.mainAxis, ot2 = T2 ? -k2[B2] / 2 + V2 + nt2 + it2 + $2.mainAxis : Y2 + nt2 + it2 + $2.mainAxis, rt2 = e2.elements.arrow && K(e2.elements.arrow), at2 = rt2 ? "y" === C2 ? rt2.clientTop || 0 : rt2.clientLeft || 0 : 0, lt2 = null != (j2 = null == D2 ? void 0 : D2[C2]) ? j2 : 0, ct2 = W2 + ot2 - lt2, ht2 = X(b2 ? N(q2, W2 + st2 - lt2 - at2) : q2, W2, b2 ? P(R2, ct2) : R2);
            x2[C2] = ht2, M2[C2] = ht2 - W2;
          }
          if (d2) {
            var ut2, dt2 = "x" === C2 ? n : r, ft2 = "x" === C2 ? s : o, pt2 = x2[O2], mt2 = "y" === O2 ? "height" : "width", gt2 = pt2 + w2[dt2], bt2 = pt2 - w2[ft2], vt2 = -1 !== [n, r].indexOf(A2), yt2 = null != (ut2 = null == D2 ? void 0 : D2[O2]) ? ut2 : 0, wt2 = vt2 ? gt2 : pt2 - k2[mt2] - S2[mt2] - yt2 + $2.altAxis, At2 = vt2 ? pt2 + k2[mt2] + S2[mt2] - yt2 - $2.altAxis : bt2, Et2 = b2 && vt2 ? (function(t3, e3, i3) {
              var n2 = X(t3, e3, i3);
              return n2 > i3 ? i3 : n2;
            })(wt2, pt2, At2) : X(b2 ? wt2 : gt2, pt2, b2 ? At2 : bt2);
            x2[O2] = Et2, M2[O2] = Et2 - pt2;
          }
          e2.modifiersData[a2] = M2;
        }
      }, requiresIfExists: ["offset"] };
      function Ot(t2, e2, i2) {
        void 0 === i2 && (i2 = false);
        var n2, s2, o2 = L(e2), r2 = L(e2) && (function(t3) {
          var e3 = t3.getBoundingClientRect(), i3 = M(e3.width) / t3.offsetWidth || 1, n3 = M(e3.height) / t3.offsetHeight || 1;
          return 1 !== i3 || 1 !== n3;
        })(e2), a2 = R(e2), l2 = H(t2, r2, i2), c2 = { scrollLeft: 0, scrollTop: 0 }, h2 = { x: 0, y: 0 };
        return (o2 || !o2 && !i2) && (("body" !== x(e2) || ut(a2)) && (c2 = (n2 = e2) !== k(n2) && L(n2) ? { scrollLeft: (s2 = n2).scrollLeft, scrollTop: s2.scrollTop } : ct(n2)), L(e2) ? ((h2 = H(e2, true)).x += e2.clientLeft, h2.y += e2.clientTop) : a2 && (h2.x = ht(a2))), { x: l2.left + c2.scrollLeft - h2.x, y: l2.top + c2.scrollTop - h2.y, width: l2.width, height: l2.height };
      }
      function xt(t2) {
        var e2 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Set(), n2 = [];
        function s2(t3) {
          i2.add(t3.name), [].concat(t3.requires || [], t3.requiresIfExists || []).forEach(function(t4) {
            if (!i2.has(t4)) {
              var n3 = e2.get(t4);
              n3 && s2(n3);
            }
          }), n2.push(t3);
        }
        return t2.forEach(function(t3) {
          e2.set(t3.name, t3);
        }), t2.forEach(function(t3) {
          i2.has(t3.name) || s2(t3);
        }), n2;
      }
      var kt = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function St() {
        for (var t2 = arguments.length, e2 = new Array(t2), i2 = 0; i2 < t2; i2++) e2[i2] = arguments[i2];
        return !e2.some(function(t3) {
          return !(t3 && "function" == typeof t3.getBoundingClientRect);
        });
      }
      function Lt(t2) {
        void 0 === t2 && (t2 = {});
        var e2 = t2, i2 = e2.defaultModifiers, n2 = void 0 === i2 ? [] : i2, s2 = e2.defaultOptions, o2 = void 0 === s2 ? kt : s2;
        return function(t3, e3, i3) {
          void 0 === i3 && (i3 = o2);
          var s3, r2, a2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, kt, o2), modifiersData: {}, elements: { reference: t3, popper: e3 }, attributes: {}, styles: {} }, l2 = [], c2 = false, h2 = { state: a2, setOptions: function(i4) {
            var s4 = "function" == typeof i4 ? i4(a2.options) : i4;
            u2(), a2.options = Object.assign({}, o2, a2.options, s4), a2.scrollParents = { reference: S(t3) ? ft(t3) : t3.contextElement ? ft(t3.contextElement) : [], popper: ft(e3) };
            var r3, c3, d2 = (function(t4) {
              var e4 = xt(t4);
              return O.reduce(function(t5, i5) {
                return t5.concat(e4.filter(function(t6) {
                  return t6.phase === i5;
                }));
              }, []);
            })((r3 = [].concat(n2, a2.options.modifiers), c3 = r3.reduce(function(t4, e4) {
              var i5 = t4[e4.name];
              return t4[e4.name] = i5 ? Object.assign({}, i5, e4, { options: Object.assign({}, i5.options, e4.options), data: Object.assign({}, i5.data, e4.data) }) : e4, t4;
            }, {}), Object.keys(c3).map(function(t4) {
              return c3[t4];
            })));
            return a2.orderedModifiers = d2.filter(function(t4) {
              return t4.enabled;
            }), a2.orderedModifiers.forEach(function(t4) {
              var e4 = t4.name, i5 = t4.options, n3 = void 0 === i5 ? {} : i5, s5 = t4.effect;
              if ("function" == typeof s5) {
                var o3 = s5({ state: a2, name: e4, instance: h2, options: n3 });
                l2.push(o3 || function() {
                });
              }
            }), h2.update();
          }, forceUpdate: function() {
            if (!c2) {
              var t4 = a2.elements, e4 = t4.reference, i4 = t4.popper;
              if (St(e4, i4)) {
                a2.rects = { reference: Ot(e4, K(i4), "fixed" === a2.options.strategy), popper: z(i4) }, a2.reset = false, a2.placement = a2.options.placement, a2.orderedModifiers.forEach(function(t5) {
                  return a2.modifiersData[t5.name] = Object.assign({}, t5.data);
                });
                for (var n3 = 0; n3 < a2.orderedModifiers.length; n3++) if (true !== a2.reset) {
                  var s4 = a2.orderedModifiers[n3], o3 = s4.fn, r3 = s4.options, l3 = void 0 === r3 ? {} : r3, u3 = s4.name;
                  "function" == typeof o3 && (a2 = o3({ state: a2, options: l3, name: u3, instance: h2 }) || a2);
                } else a2.reset = false, n3 = -1;
              }
            }
          }, update: (s3 = function() {
            return new Promise(function(t4) {
              h2.forceUpdate(), t4(a2);
            });
          }, function() {
            return r2 || (r2 = new Promise(function(t4) {
              Promise.resolve().then(function() {
                r2 = void 0, t4(s3());
              });
            })), r2;
          }), destroy: function() {
            u2(), c2 = true;
          } };
          if (!St(t3, e3)) return h2;
          function u2() {
            l2.forEach(function(t4) {
              return t4();
            }), l2 = [];
          }
          return h2.setOptions(i3).then(function(t4) {
            !c2 && i3.onFirstUpdate && i3.onFirstUpdate(t4);
          }), h2;
        };
      }
      var $t = Lt(), Dt = Lt({ defaultModifiers: [st, Tt, it, D] }), It = Lt({ defaultModifiers: [st, Tt, it, D, Et, vt, Ct, J, At] });
      const Pt = Object.freeze(Object.defineProperty({ __proto__: null, afterMain: A, afterRead: v, afterWrite: C, applyStyles: D, arrow: J, auto: a, basePlacements: l, beforeMain: y, beforeRead: _, beforeWrite: E, bottom: s, clippingParents: u, computeStyles: it, createPopper: It, createPopperBase: $t, createPopperLite: Dt, detectOverflow: _t, end: h, eventListeners: st, flip: vt, hide: At, left: r, main: w, modifierPhases: O, offset: Et, placements: g, popper: f, popperGenerator: Lt, popperOffsets: Tt, preventOverflow: Ct, read: b, reference: p, right: o, start: c, top: n, variationPlacements: m, viewport: d, write: T }, Symbol.toStringTag, { value: "Module" })), Nt = /* @__PURE__ */ new Map(), Mt = { set(t2, e2, i2) {
        Nt.has(t2) || Nt.set(t2, /* @__PURE__ */ new Map());
        const n2 = Nt.get(t2);
        n2.has(e2) || 0 === n2.size ? n2.set(e2, i2) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n2.keys())[0]}.`);
      }, get: (t2, e2) => Nt.has(t2) && Nt.get(t2).get(e2) || null, remove(t2, e2) {
        if (!Nt.has(t2)) return;
        const i2 = Nt.get(t2);
        i2.delete(e2), 0 === i2.size && Nt.delete(t2);
      } }, jt = "transitionend", Ft = (t2) => (t2 && window.CSS && window.CSS.escape && (t2 = t2.replace(/#([^\s"#']+)/g, (t3, e2) => `#${CSS.escape(e2)}`)), t2), Ht = (t2) => null == t2 ? `${t2}` : Object.prototype.toString.call(t2).match(/\s([a-z]+)/i)[1].toLowerCase(), zt = (t2) => {
        t2.dispatchEvent(new Event(jt));
      }, Bt = (t2) => !(!t2 || "object" != typeof t2) && (void 0 !== t2.jquery && (t2 = t2[0]), void 0 !== t2.nodeType), Wt = (t2) => Bt(t2) ? t2.jquery ? t2[0] : t2 : "string" == typeof t2 && t2.length > 0 ? document.querySelector(Ft(t2)) : null, qt = (t2) => {
        if (!Bt(t2) || 0 === t2.getClientRects().length) return false;
        const e2 = "visible" === getComputedStyle(t2).getPropertyValue("visibility"), i2 = t2.closest("details:not([open])");
        if (!i2) return e2;
        if (i2 !== t2) {
          const e3 = t2.closest("summary");
          if (e3 && e3.parentNode !== i2) return false;
          if (null === e3) return false;
        }
        return e2;
      }, Rt = (t2) => !t2 || t2.nodeType !== Node.ELEMENT_NODE || !!t2.classList.contains("disabled") || (void 0 !== t2.disabled ? t2.disabled : t2.hasAttribute("disabled") && "false" !== t2.getAttribute("disabled")), Vt = (t2) => {
        if (!document.documentElement.attachShadow) return null;
        if ("function" == typeof t2.getRootNode) {
          const e2 = t2.getRootNode();
          return e2 instanceof ShadowRoot ? e2 : null;
        }
        return t2 instanceof ShadowRoot ? t2 : t2.parentNode ? Vt(t2.parentNode) : null;
      }, Ut = () => {
      }, Kt = (t2) => {
        t2.offsetHeight;
      }, Qt = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, Xt = [], Yt = () => "rtl" === document.documentElement.dir, Gt = (t2) => {
        var e2;
        e2 = () => {
          const e3 = Qt();
          if (e3) {
            const i2 = t2.NAME, n2 = e3.fn[i2];
            e3.fn[i2] = t2.jQueryInterface, e3.fn[i2].Constructor = t2, e3.fn[i2].noConflict = () => (e3.fn[i2] = n2, t2.jQueryInterface);
          }
        }, "loading" === document.readyState ? (Xt.length || document.addEventListener("DOMContentLoaded", () => {
          for (const t3 of Xt) t3();
        }), Xt.push(e2)) : e2();
      }, Jt = (t2, e2 = [], i2 = t2) => "function" == typeof t2 ? t2.call(...e2) : i2, Zt = (t2, e2, i2 = true) => {
        if (!i2) return void Jt(t2);
        const n2 = ((t3) => {
          if (!t3) return 0;
          let { transitionDuration: e3, transitionDelay: i3 } = window.getComputedStyle(t3);
          const n3 = Number.parseFloat(e3), s3 = Number.parseFloat(i3);
          return n3 || s3 ? (e3 = e3.split(",")[0], i3 = i3.split(",")[0], 1e3 * (Number.parseFloat(e3) + Number.parseFloat(i3))) : 0;
        })(e2) + 5;
        let s2 = false;
        const o2 = ({ target: i3 }) => {
          i3 === e2 && (s2 = true, e2.removeEventListener(jt, o2), Jt(t2));
        };
        e2.addEventListener(jt, o2), setTimeout(() => {
          s2 || zt(e2);
        }, n2);
      }, te = (t2, e2, i2, n2) => {
        const s2 = t2.length;
        let o2 = t2.indexOf(e2);
        return -1 === o2 ? !i2 && n2 ? t2[s2 - 1] : t2[0] : (o2 += i2 ? 1 : -1, n2 && (o2 = (o2 + s2) % s2), t2[Math.max(0, Math.min(o2, s2 - 1))]);
      }, ee = /[^.]*(?=\..*)\.|.*/, ie = /\..*/, ne = /::\d+$/, se = {};
      let oe = 1;
      const re = { mouseenter: "mouseover", mouseleave: "mouseout" }, ae = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
      function le(t2, e2) {
        return e2 && `${e2}::${oe++}` || t2.uidEvent || oe++;
      }
      function ce(t2) {
        const e2 = le(t2);
        return t2.uidEvent = e2, se[e2] = se[e2] || {}, se[e2];
      }
      function he(t2, e2, i2 = null) {
        return Object.values(t2).find((t3) => t3.callable === e2 && t3.delegationSelector === i2);
      }
      function ue(t2, e2, i2) {
        const n2 = "string" == typeof e2, s2 = n2 ? i2 : e2 || i2;
        let o2 = me(t2);
        return ae.has(o2) || (o2 = t2), [n2, s2, o2];
      }
      function de(t2, e2, i2, n2, s2) {
        if ("string" != typeof e2 || !t2) return;
        let [o2, r2, a2] = ue(e2, i2, n2);
        if (e2 in re) {
          const t3 = (t4) => function(e3) {
            if (!e3.relatedTarget || e3.relatedTarget !== e3.delegateTarget && !e3.delegateTarget.contains(e3.relatedTarget)) return t4.call(this, e3);
          };
          r2 = t3(r2);
        }
        const l2 = ce(t2), c2 = l2[a2] || (l2[a2] = {}), h2 = he(c2, r2, o2 ? i2 : null);
        if (h2) return void (h2.oneOff = h2.oneOff && s2);
        const u2 = le(r2, e2.replace(ee, "")), d2 = o2 ? /* @__PURE__ */ (function(t3, e3, i3) {
          return function n3(s3) {
            const o3 = t3.querySelectorAll(e3);
            for (let { target: r3 } = s3; r3 && r3 !== this; r3 = r3.parentNode) for (const a3 of o3) if (a3 === r3) return _e(s3, { delegateTarget: r3 }), n3.oneOff && ge.off(t3, s3.type, e3, i3), i3.apply(r3, [s3]);
          };
        })(t2, i2, r2) : /* @__PURE__ */ (function(t3, e3) {
          return function i3(n3) {
            return _e(n3, { delegateTarget: t3 }), i3.oneOff && ge.off(t3, n3.type, e3), e3.apply(t3, [n3]);
          };
        })(t2, r2);
        d2.delegationSelector = o2 ? i2 : null, d2.callable = r2, d2.oneOff = s2, d2.uidEvent = u2, c2[u2] = d2, t2.addEventListener(a2, d2, o2);
      }
      function fe(t2, e2, i2, n2, s2) {
        const o2 = he(e2[i2], n2, s2);
        o2 && (t2.removeEventListener(i2, o2, Boolean(s2)), delete e2[i2][o2.uidEvent]);
      }
      function pe(t2, e2, i2, n2) {
        const s2 = e2[i2] || {};
        for (const [o2, r2] of Object.entries(s2)) o2.includes(n2) && fe(t2, e2, i2, r2.callable, r2.delegationSelector);
      }
      function me(t2) {
        return t2 = t2.replace(ie, ""), re[t2] || t2;
      }
      const ge = { on(t2, e2, i2, n2) {
        de(t2, e2, i2, n2, false);
      }, one(t2, e2, i2, n2) {
        de(t2, e2, i2, n2, true);
      }, off(t2, e2, i2, n2) {
        if ("string" != typeof e2 || !t2) return;
        const [s2, o2, r2] = ue(e2, i2, n2), a2 = r2 !== e2, l2 = ce(t2), c2 = l2[r2] || {}, h2 = e2.startsWith(".");
        if (void 0 === o2) {
          if (h2) for (const i3 of Object.keys(l2)) pe(t2, l2, i3, e2.slice(1));
          for (const [i3, n3] of Object.entries(c2)) {
            const s3 = i3.replace(ne, "");
            a2 && !e2.includes(s3) || fe(t2, l2, r2, n3.callable, n3.delegationSelector);
          }
        } else {
          if (!Object.keys(c2).length) return;
          fe(t2, l2, r2, o2, s2 ? i2 : null);
        }
      }, trigger(t2, e2, i2) {
        if ("string" != typeof e2 || !t2) return null;
        const n2 = Qt();
        let s2 = null, o2 = true, r2 = true, a2 = false;
        e2 !== me(e2) && n2 && (s2 = n2.Event(e2, i2), n2(t2).trigger(s2), o2 = !s2.isPropagationStopped(), r2 = !s2.isImmediatePropagationStopped(), a2 = s2.isDefaultPrevented());
        const l2 = _e(new Event(e2, { bubbles: o2, cancelable: true }), i2);
        return a2 && l2.preventDefault(), r2 && t2.dispatchEvent(l2), l2.defaultPrevented && s2 && s2.preventDefault(), l2;
      } };
      function _e(t2, e2 = {}) {
        for (const [i2, n2] of Object.entries(e2)) try {
          t2[i2] = n2;
        } catch (e3) {
          Object.defineProperty(t2, i2, { configurable: true, get: () => n2 });
        }
        return t2;
      }
      function be(t2) {
        if ("true" === t2) return true;
        if ("false" === t2) return false;
        if (t2 === Number(t2).toString()) return Number(t2);
        if ("" === t2 || "null" === t2) return null;
        if ("string" != typeof t2) return t2;
        try {
          return JSON.parse(decodeURIComponent(t2));
        } catch (e2) {
          return t2;
        }
      }
      function ve(t2) {
        return t2.replace(/[A-Z]/g, (t3) => `-${t3.toLowerCase()}`);
      }
      const ye = { setDataAttribute(t2, e2, i2) {
        t2.setAttribute(`data-bs-${ve(e2)}`, i2);
      }, removeDataAttribute(t2, e2) {
        t2.removeAttribute(`data-bs-${ve(e2)}`);
      }, getDataAttributes(t2) {
        if (!t2) return {};
        const e2 = {}, i2 = Object.keys(t2.dataset).filter((t3) => t3.startsWith("bs") && !t3.startsWith("bsConfig"));
        for (const n2 of i2) {
          let i3 = n2.replace(/^bs/, "");
          i3 = i3.charAt(0).toLowerCase() + i3.slice(1), e2[i3] = be(t2.dataset[n2]);
        }
        return e2;
      }, getDataAttribute: (t2, e2) => be(t2.getAttribute(`data-bs-${ve(e2)}`)) };
      class we {
        static get Default() {
          return {};
        }
        static get DefaultType() {
          return {};
        }
        static get NAME() {
          throw new Error('You have to implement the static method "NAME", for each component!');
        }
        _getConfig(t2) {
          return t2 = this._mergeConfigObj(t2), t2 = this._configAfterMerge(t2), this._typeCheckConfig(t2), t2;
        }
        _configAfterMerge(t2) {
          return t2;
        }
        _mergeConfigObj(t2, e2) {
          const i2 = Bt(e2) ? ye.getDataAttribute(e2, "config") : {};
          return { ...this.constructor.Default, ..."object" == typeof i2 ? i2 : {}, ...Bt(e2) ? ye.getDataAttributes(e2) : {}, ..."object" == typeof t2 ? t2 : {} };
        }
        _typeCheckConfig(t2, e2 = this.constructor.DefaultType) {
          for (const [i2, n2] of Object.entries(e2)) {
            const e3 = t2[i2], s2 = Bt(e3) ? "element" : Ht(e3);
            if (!new RegExp(n2).test(s2)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${i2}" provided type "${s2}" but expected type "${n2}".`);
          }
        }
      }
      class Ae extends we {
        constructor(t2, e2) {
          super(), (t2 = Wt(t2)) && (this._element = t2, this._config = this._getConfig(e2), Mt.set(this._element, this.constructor.DATA_KEY, this));
        }
        dispose() {
          Mt.remove(this._element, this.constructor.DATA_KEY), ge.off(this._element, this.constructor.EVENT_KEY);
          for (const t2 of Object.getOwnPropertyNames(this)) this[t2] = null;
        }
        _queueCallback(t2, e2, i2 = true) {
          Zt(t2, e2, i2);
        }
        _getConfig(t2) {
          return t2 = this._mergeConfigObj(t2, this._element), t2 = this._configAfterMerge(t2), this._typeCheckConfig(t2), t2;
        }
        static getInstance(t2) {
          return Mt.get(Wt(t2), this.DATA_KEY);
        }
        static getOrCreateInstance(t2, e2 = {}) {
          return this.getInstance(t2) || new this(t2, "object" == typeof e2 ? e2 : null);
        }
        static get VERSION() {
          return "5.3.7";
        }
        static get DATA_KEY() {
          return `bs.${this.NAME}`;
        }
        static get EVENT_KEY() {
          return `.${this.DATA_KEY}`;
        }
        static eventName(t2) {
          return `${t2}${this.EVENT_KEY}`;
        }
      }
      const Ee = (t2) => {
        let e2 = t2.getAttribute("data-bs-target");
        if (!e2 || "#" === e2) {
          let i2 = t2.getAttribute("href");
          if (!i2 || !i2.includes("#") && !i2.startsWith(".")) return null;
          i2.includes("#") && !i2.startsWith("#") && (i2 = `#${i2.split("#")[1]}`), e2 = i2 && "#" !== i2 ? i2.trim() : null;
        }
        return e2 ? e2.split(",").map((t3) => Ft(t3)).join(",") : null;
      }, Te = { find: (t2, e2 = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e2, t2)), findOne: (t2, e2 = document.documentElement) => Element.prototype.querySelector.call(e2, t2), children: (t2, e2) => [].concat(...t2.children).filter((t3) => t3.matches(e2)), parents(t2, e2) {
        const i2 = [];
        let n2 = t2.parentNode.closest(e2);
        for (; n2; ) i2.push(n2), n2 = n2.parentNode.closest(e2);
        return i2;
      }, prev(t2, e2) {
        let i2 = t2.previousElementSibling;
        for (; i2; ) {
          if (i2.matches(e2)) return [i2];
          i2 = i2.previousElementSibling;
        }
        return [];
      }, next(t2, e2) {
        let i2 = t2.nextElementSibling;
        for (; i2; ) {
          if (i2.matches(e2)) return [i2];
          i2 = i2.nextElementSibling;
        }
        return [];
      }, focusableChildren(t2) {
        const e2 = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t3) => `${t3}:not([tabindex^="-"])`).join(",");
        return this.find(e2, t2).filter((t3) => !Rt(t3) && qt(t3));
      }, getSelectorFromElement(t2) {
        const e2 = Ee(t2);
        return e2 && Te.findOne(e2) ? e2 : null;
      }, getElementFromSelector(t2) {
        const e2 = Ee(t2);
        return e2 ? Te.findOne(e2) : null;
      }, getMultipleElementsFromSelector(t2) {
        const e2 = Ee(t2);
        return e2 ? Te.find(e2) : [];
      } }, Ce = (t2, e2 = "hide") => {
        const i2 = `click.dismiss${t2.EVENT_KEY}`, n2 = t2.NAME;
        ge.on(document, i2, `[data-bs-dismiss="${n2}"]`, function(i3) {
          if (["A", "AREA"].includes(this.tagName) && i3.preventDefault(), Rt(this)) return;
          const s2 = Te.getElementFromSelector(this) || this.closest(`.${n2}`);
          t2.getOrCreateInstance(s2)[e2]();
        });
      }, Oe = ".bs.alert", xe = `close${Oe}`, ke = `closed${Oe}`;
      class Se extends Ae {
        static get NAME() {
          return "alert";
        }
        close() {
          if (ge.trigger(this._element, xe).defaultPrevented) return;
          this._element.classList.remove("show");
          const t2 = this._element.classList.contains("fade");
          this._queueCallback(() => this._destroyElement(), this._element, t2);
        }
        _destroyElement() {
          this._element.remove(), ge.trigger(this._element, ke), this.dispose();
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = Se.getOrCreateInstance(this);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2] || t2.startsWith("_") || "constructor" === t2) throw new TypeError(`No method named "${t2}"`);
              e2[t2](this);
            }
          });
        }
      }
      Ce(Se, "close"), Gt(Se);
      const Le = '[data-bs-toggle="button"]';
      class $e extends Ae {
        static get NAME() {
          return "button";
        }
        toggle() {
          this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = $e.getOrCreateInstance(this);
            "toggle" === t2 && e2[t2]();
          });
        }
      }
      ge.on(document, "click.bs.button.data-api", Le, (t2) => {
        t2.preventDefault();
        const e2 = t2.target.closest(Le);
        $e.getOrCreateInstance(e2).toggle();
      }), Gt($e);
      const De = ".bs.swipe", Ie = `touchstart${De}`, Pe = `touchmove${De}`, Ne = `touchend${De}`, Me = `pointerdown${De}`, je = `pointerup${De}`, Fe = { endCallback: null, leftCallback: null, rightCallback: null }, He = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" };
      class ze extends we {
        constructor(t2, e2) {
          super(), this._element = t2, t2 && ze.isSupported() && (this._config = this._getConfig(e2), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
        }
        static get Default() {
          return Fe;
        }
        static get DefaultType() {
          return He;
        }
        static get NAME() {
          return "swipe";
        }
        dispose() {
          ge.off(this._element, De);
        }
        _start(t2) {
          this._supportPointerEvents ? this._eventIsPointerPenTouch(t2) && (this._deltaX = t2.clientX) : this._deltaX = t2.touches[0].clientX;
        }
        _end(t2) {
          this._eventIsPointerPenTouch(t2) && (this._deltaX = t2.clientX - this._deltaX), this._handleSwipe(), Jt(this._config.endCallback);
        }
        _move(t2) {
          this._deltaX = t2.touches && t2.touches.length > 1 ? 0 : t2.touches[0].clientX - this._deltaX;
        }
        _handleSwipe() {
          const t2 = Math.abs(this._deltaX);
          if (t2 <= 40) return;
          const e2 = t2 / this._deltaX;
          this._deltaX = 0, e2 && Jt(e2 > 0 ? this._config.rightCallback : this._config.leftCallback);
        }
        _initEvents() {
          this._supportPointerEvents ? (ge.on(this._element, Me, (t2) => this._start(t2)), ge.on(this._element, je, (t2) => this._end(t2)), this._element.classList.add("pointer-event")) : (ge.on(this._element, Ie, (t2) => this._start(t2)), ge.on(this._element, Pe, (t2) => this._move(t2)), ge.on(this._element, Ne, (t2) => this._end(t2)));
        }
        _eventIsPointerPenTouch(t2) {
          return this._supportPointerEvents && ("pen" === t2.pointerType || "touch" === t2.pointerType);
        }
        static isSupported() {
          return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
        }
      }
      const Be = ".bs.carousel", We = ".data-api", qe = "ArrowLeft", Re = "ArrowRight", Ve = "next", Ue = "prev", Ke = "left", Qe = "right", Xe = `slide${Be}`, Ye = `slid${Be}`, Ge = `keydown${Be}`, Je = `mouseenter${Be}`, Ze = `mouseleave${Be}`, ti = `dragstart${Be}`, ei = `load${Be}${We}`, ii = `click${Be}${We}`, ni = "carousel", si = "active", oi = ".active", ri = ".carousel-item", ai = oi + ri, li = { [qe]: Qe, [Re]: Ke }, ci = { interval: 5e3, keyboard: true, pause: "hover", ride: false, touch: true, wrap: true }, hi = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" };
      class ui extends Ae {
        constructor(t2, e2) {
          super(t2, e2), this._interval = null, this._activeElement = null, this._isSliding = false, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = Te.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === ni && this.cycle();
        }
        static get Default() {
          return ci;
        }
        static get DefaultType() {
          return hi;
        }
        static get NAME() {
          return "carousel";
        }
        next() {
          this._slide(Ve);
        }
        nextWhenVisible() {
          !document.hidden && qt(this._element) && this.next();
        }
        prev() {
          this._slide(Ue);
        }
        pause() {
          this._isSliding && zt(this._element), this._clearInterval();
        }
        cycle() {
          this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
        }
        _maybeEnableCycle() {
          this._config.ride && (this._isSliding ? ge.one(this._element, Ye, () => this.cycle()) : this.cycle());
        }
        to(t2) {
          const e2 = this._getItems();
          if (t2 > e2.length - 1 || t2 < 0) return;
          if (this._isSliding) return void ge.one(this._element, Ye, () => this.to(t2));
          const i2 = this._getItemIndex(this._getActive());
          if (i2 === t2) return;
          const n2 = t2 > i2 ? Ve : Ue;
          this._slide(n2, e2[t2]);
        }
        dispose() {
          this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
        }
        _configAfterMerge(t2) {
          return t2.defaultInterval = t2.interval, t2;
        }
        _addEventListeners() {
          this._config.keyboard && ge.on(this._element, Ge, (t2) => this._keydown(t2)), "hover" === this._config.pause && (ge.on(this._element, Je, () => this.pause()), ge.on(this._element, Ze, () => this._maybeEnableCycle())), this._config.touch && ze.isSupported() && this._addTouchEventListeners();
        }
        _addTouchEventListeners() {
          for (const t3 of Te.find(".carousel-item img", this._element)) ge.on(t3, ti, (t4) => t4.preventDefault());
          const t2 = { leftCallback: () => this._slide(this._directionToOrder(Ke)), rightCallback: () => this._slide(this._directionToOrder(Qe)), endCallback: () => {
            "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval));
          } };
          this._swipeHelper = new ze(this._element, t2);
        }
        _keydown(t2) {
          if (/input|textarea/i.test(t2.target.tagName)) return;
          const e2 = li[t2.key];
          e2 && (t2.preventDefault(), this._slide(this._directionToOrder(e2)));
        }
        _getItemIndex(t2) {
          return this._getItems().indexOf(t2);
        }
        _setActiveIndicatorElement(t2) {
          if (!this._indicatorsElement) return;
          const e2 = Te.findOne(oi, this._indicatorsElement);
          e2.classList.remove(si), e2.removeAttribute("aria-current");
          const i2 = Te.findOne(`[data-bs-slide-to="${t2}"]`, this._indicatorsElement);
          i2 && (i2.classList.add(si), i2.setAttribute("aria-current", "true"));
        }
        _updateInterval() {
          const t2 = this._activeElement || this._getActive();
          if (!t2) return;
          const e2 = Number.parseInt(t2.getAttribute("data-bs-interval"), 10);
          this._config.interval = e2 || this._config.defaultInterval;
        }
        _slide(t2, e2 = null) {
          if (this._isSliding) return;
          const i2 = this._getActive(), n2 = t2 === Ve, s2 = e2 || te(this._getItems(), i2, n2, this._config.wrap);
          if (s2 === i2) return;
          const o2 = this._getItemIndex(s2), r2 = (e3) => ge.trigger(this._element, e3, { relatedTarget: s2, direction: this._orderToDirection(t2), from: this._getItemIndex(i2), to: o2 });
          if (r2(Xe).defaultPrevented) return;
          if (!i2 || !s2) return;
          const a2 = Boolean(this._interval);
          this.pause(), this._isSliding = true, this._setActiveIndicatorElement(o2), this._activeElement = s2;
          const l2 = n2 ? "carousel-item-start" : "carousel-item-end", c2 = n2 ? "carousel-item-next" : "carousel-item-prev";
          s2.classList.add(c2), Kt(s2), i2.classList.add(l2), s2.classList.add(l2), this._queueCallback(() => {
            s2.classList.remove(l2, c2), s2.classList.add(si), i2.classList.remove(si, c2, l2), this._isSliding = false, r2(Ye);
          }, i2, this._isAnimated()), a2 && this.cycle();
        }
        _isAnimated() {
          return this._element.classList.contains("slide");
        }
        _getActive() {
          return Te.findOne(ai, this._element);
        }
        _getItems() {
          return Te.find(ri, this._element);
        }
        _clearInterval() {
          this._interval && (clearInterval(this._interval), this._interval = null);
        }
        _directionToOrder(t2) {
          return Yt() ? t2 === Ke ? Ue : Ve : t2 === Ke ? Ve : Ue;
        }
        _orderToDirection(t2) {
          return Yt() ? t2 === Ue ? Ke : Qe : t2 === Ue ? Qe : Ke;
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = ui.getOrCreateInstance(this, t2);
            if ("number" != typeof t2) {
              if ("string" == typeof t2) {
                if (void 0 === e2[t2] || t2.startsWith("_") || "constructor" === t2) throw new TypeError(`No method named "${t2}"`);
                e2[t2]();
              }
            } else e2.to(t2);
          });
        }
      }
      ge.on(document, ii, "[data-bs-slide], [data-bs-slide-to]", function(t2) {
        const e2 = Te.getElementFromSelector(this);
        if (!e2 || !e2.classList.contains(ni)) return;
        t2.preventDefault();
        const i2 = ui.getOrCreateInstance(e2), n2 = this.getAttribute("data-bs-slide-to");
        return n2 ? (i2.to(n2), void i2._maybeEnableCycle()) : "next" === ye.getDataAttribute(this, "slide") ? (i2.next(), void i2._maybeEnableCycle()) : (i2.prev(), void i2._maybeEnableCycle());
      }), ge.on(window, ei, () => {
        const t2 = Te.find('[data-bs-ride="carousel"]');
        for (const e2 of t2) ui.getOrCreateInstance(e2);
      }), Gt(ui);
      const di = ".bs.collapse", fi = `show${di}`, pi = `shown${di}`, mi = `hide${di}`, gi = `hidden${di}`, _i = `click${di}.data-api`, bi = "show", vi = "collapse", yi = "collapsing", wi = `:scope .${vi} .${vi}`, Ai = '[data-bs-toggle="collapse"]', Ei = { parent: null, toggle: true }, Ti = { parent: "(null|element)", toggle: "boolean" };
      class Ci extends Ae {
        constructor(t2, e2) {
          super(t2, e2), this._isTransitioning = false, this._triggerArray = [];
          const i2 = Te.find(Ai);
          for (const t3 of i2) {
            const e3 = Te.getSelectorFromElement(t3), i3 = Te.find(e3).filter((t4) => t4 === this._element);
            null !== e3 && i3.length && this._triggerArray.push(t3);
          }
          this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
        }
        static get Default() {
          return Ei;
        }
        static get DefaultType() {
          return Ti;
        }
        static get NAME() {
          return "collapse";
        }
        toggle() {
          this._isShown() ? this.hide() : this.show();
        }
        show() {
          if (this._isTransitioning || this._isShown()) return;
          let t2 = [];
          if (this._config.parent && (t2 = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t3) => t3 !== this._element).map((t3) => Ci.getOrCreateInstance(t3, { toggle: false }))), t2.length && t2[0]._isTransitioning) return;
          if (ge.trigger(this._element, fi).defaultPrevented) return;
          for (const e3 of t2) e3.hide();
          const e2 = this._getDimension();
          this._element.classList.remove(vi), this._element.classList.add(yi), this._element.style[e2] = 0, this._addAriaAndCollapsedClass(this._triggerArray, true), this._isTransitioning = true;
          const i2 = `scroll${e2[0].toUpperCase() + e2.slice(1)}`;
          this._queueCallback(() => {
            this._isTransitioning = false, this._element.classList.remove(yi), this._element.classList.add(vi, bi), this._element.style[e2] = "", ge.trigger(this._element, pi);
          }, this._element, true), this._element.style[e2] = `${this._element[i2]}px`;
        }
        hide() {
          if (this._isTransitioning || !this._isShown()) return;
          if (ge.trigger(this._element, mi).defaultPrevented) return;
          const t2 = this._getDimension();
          this._element.style[t2] = `${this._element.getBoundingClientRect()[t2]}px`, Kt(this._element), this._element.classList.add(yi), this._element.classList.remove(vi, bi);
          for (const t3 of this._triggerArray) {
            const e2 = Te.getElementFromSelector(t3);
            e2 && !this._isShown(e2) && this._addAriaAndCollapsedClass([t3], false);
          }
          this._isTransitioning = true, this._element.style[t2] = "", this._queueCallback(() => {
            this._isTransitioning = false, this._element.classList.remove(yi), this._element.classList.add(vi), ge.trigger(this._element, gi);
          }, this._element, true);
        }
        _isShown(t2 = this._element) {
          return t2.classList.contains(bi);
        }
        _configAfterMerge(t2) {
          return t2.toggle = Boolean(t2.toggle), t2.parent = Wt(t2.parent), t2;
        }
        _getDimension() {
          return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
        }
        _initializeChildren() {
          if (!this._config.parent) return;
          const t2 = this._getFirstLevelChildren(Ai);
          for (const e2 of t2) {
            const t3 = Te.getElementFromSelector(e2);
            t3 && this._addAriaAndCollapsedClass([e2], this._isShown(t3));
          }
        }
        _getFirstLevelChildren(t2) {
          const e2 = Te.find(wi, this._config.parent);
          return Te.find(t2, this._config.parent).filter((t3) => !e2.includes(t3));
        }
        _addAriaAndCollapsedClass(t2, e2) {
          if (t2.length) for (const i2 of t2) i2.classList.toggle("collapsed", !e2), i2.setAttribute("aria-expanded", e2);
        }
        static jQueryInterface(t2) {
          const e2 = {};
          return "string" == typeof t2 && /show|hide/.test(t2) && (e2.toggle = false), this.each(function() {
            const i2 = Ci.getOrCreateInstance(this, e2);
            if ("string" == typeof t2) {
              if (void 0 === i2[t2]) throw new TypeError(`No method named "${t2}"`);
              i2[t2]();
            }
          });
        }
      }
      ge.on(document, _i, Ai, function(t2) {
        ("A" === t2.target.tagName || t2.delegateTarget && "A" === t2.delegateTarget.tagName) && t2.preventDefault();
        for (const t3 of Te.getMultipleElementsFromSelector(this)) Ci.getOrCreateInstance(t3, { toggle: false }).toggle();
      }), Gt(Ci);
      const Oi = "dropdown", xi = ".bs.dropdown", ki = ".data-api", Si = "ArrowUp", Li = "ArrowDown", $i = `hide${xi}`, Di = `hidden${xi}`, Ii = `show${xi}`, Pi = `shown${xi}`, Ni = `click${xi}${ki}`, Mi = `keydown${xi}${ki}`, ji = `keyup${xi}${ki}`, Fi = "show", Hi = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', zi = `${Hi}.${Fi}`, Bi = ".dropdown-menu", Wi = Yt() ? "top-end" : "top-start", qi = Yt() ? "top-start" : "top-end", Ri = Yt() ? "bottom-end" : "bottom-start", Vi = Yt() ? "bottom-start" : "bottom-end", Ui = Yt() ? "left-start" : "right-start", Ki = Yt() ? "right-start" : "left-start", Qi = { autoClose: true, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, Xi = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" };
      class Yi extends Ae {
        constructor(t2, e2) {
          super(t2, e2), this._popper = null, this._parent = this._element.parentNode, this._menu = Te.next(this._element, Bi)[0] || Te.prev(this._element, Bi)[0] || Te.findOne(Bi, this._parent), this._inNavbar = this._detectNavbar();
        }
        static get Default() {
          return Qi;
        }
        static get DefaultType() {
          return Xi;
        }
        static get NAME() {
          return Oi;
        }
        toggle() {
          return this._isShown() ? this.hide() : this.show();
        }
        show() {
          if (Rt(this._element) || this._isShown()) return;
          const t2 = { relatedTarget: this._element };
          if (!ge.trigger(this._element, Ii, t2).defaultPrevented) {
            if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t3 of [].concat(...document.body.children)) ge.on(t3, "mouseover", Ut);
            this._element.focus(), this._element.setAttribute("aria-expanded", true), this._menu.classList.add(Fi), this._element.classList.add(Fi), ge.trigger(this._element, Pi, t2);
          }
        }
        hide() {
          if (Rt(this._element) || !this._isShown()) return;
          const t2 = { relatedTarget: this._element };
          this._completeHide(t2);
        }
        dispose() {
          this._popper && this._popper.destroy(), super.dispose();
        }
        update() {
          this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
        }
        _completeHide(t2) {
          if (!ge.trigger(this._element, $i, t2).defaultPrevented) {
            if ("ontouchstart" in document.documentElement) for (const t3 of [].concat(...document.body.children)) ge.off(t3, "mouseover", Ut);
            this._popper && this._popper.destroy(), this._menu.classList.remove(Fi), this._element.classList.remove(Fi), this._element.setAttribute("aria-expanded", "false"), ye.removeDataAttribute(this._menu, "popper"), ge.trigger(this._element, Di, t2), this._element.focus();
          }
        }
        _getConfig(t2) {
          if ("object" == typeof (t2 = super._getConfig(t2)).reference && !Bt(t2.reference) && "function" != typeof t2.reference.getBoundingClientRect) throw new TypeError(`${Oi.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
          return t2;
        }
        _createPopper() {
          if (void 0 === Pt) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");
          let t2 = this._element;
          "parent" === this._config.reference ? t2 = this._parent : Bt(this._config.reference) ? t2 = Wt(this._config.reference) : "object" == typeof this._config.reference && (t2 = this._config.reference);
          const e2 = this._getPopperConfig();
          this._popper = It(t2, this._menu, e2);
        }
        _isShown() {
          return this._menu.classList.contains(Fi);
        }
        _getPlacement() {
          const t2 = this._parent;
          if (t2.classList.contains("dropend")) return Ui;
          if (t2.classList.contains("dropstart")) return Ki;
          if (t2.classList.contains("dropup-center")) return "top";
          if (t2.classList.contains("dropdown-center")) return "bottom";
          const e2 = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
          return t2.classList.contains("dropup") ? e2 ? qi : Wi : e2 ? Vi : Ri;
        }
        _detectNavbar() {
          return null !== this._element.closest(".navbar");
        }
        _getOffset() {
          const { offset: t2 } = this._config;
          return "string" == typeof t2 ? t2.split(",").map((t3) => Number.parseInt(t3, 10)) : "function" == typeof t2 ? (e2) => t2(e2, this._element) : t2;
        }
        _getPopperConfig() {
          const t2 = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] };
          return (this._inNavbar || "static" === this._config.display) && (ye.setDataAttribute(this._menu, "popper", "static"), t2.modifiers = [{ name: "applyStyles", enabled: false }]), { ...t2, ...Jt(this._config.popperConfig, [void 0, t2]) };
        }
        _selectMenuItem({ key: t2, target: e2 }) {
          const i2 = Te.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t3) => qt(t3));
          i2.length && te(i2, e2, t2 === Li, !i2.includes(e2)).focus();
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = Yi.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2]) throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
        static clearMenus(t2) {
          if (2 === t2.button || "keyup" === t2.type && "Tab" !== t2.key) return;
          const e2 = Te.find(zi);
          for (const i2 of e2) {
            const e3 = Yi.getInstance(i2);
            if (!e3 || false === e3._config.autoClose) continue;
            const n2 = t2.composedPath(), s2 = n2.includes(e3._menu);
            if (n2.includes(e3._element) || "inside" === e3._config.autoClose && !s2 || "outside" === e3._config.autoClose && s2) continue;
            if (e3._menu.contains(t2.target) && ("keyup" === t2.type && "Tab" === t2.key || /input|select|option|textarea|form/i.test(t2.target.tagName))) continue;
            const o2 = { relatedTarget: e3._element };
            "click" === t2.type && (o2.clickEvent = t2), e3._completeHide(o2);
          }
        }
        static dataApiKeydownHandler(t2) {
          const e2 = /input|textarea/i.test(t2.target.tagName), i2 = "Escape" === t2.key, n2 = [Si, Li].includes(t2.key);
          if (!n2 && !i2) return;
          if (e2 && !i2) return;
          t2.preventDefault();
          const s2 = this.matches(Hi) ? this : Te.prev(this, Hi)[0] || Te.next(this, Hi)[0] || Te.findOne(Hi, t2.delegateTarget.parentNode), o2 = Yi.getOrCreateInstance(s2);
          if (n2) return t2.stopPropagation(), o2.show(), void o2._selectMenuItem(t2);
          o2._isShown() && (t2.stopPropagation(), o2.hide(), s2.focus());
        }
      }
      ge.on(document, Mi, Hi, Yi.dataApiKeydownHandler), ge.on(document, Mi, Bi, Yi.dataApiKeydownHandler), ge.on(document, Ni, Yi.clearMenus), ge.on(document, ji, Yi.clearMenus), ge.on(document, Ni, Hi, function(t2) {
        t2.preventDefault(), Yi.getOrCreateInstance(this).toggle();
      }), Gt(Yi);
      const Gi = "backdrop", Ji = "show", Zi = `mousedown.bs.${Gi}`, tn = { className: "modal-backdrop", clickCallback: null, isAnimated: false, isVisible: true, rootElement: "body" }, en = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" };
      class nn extends we {
        constructor(t2) {
          super(), this._config = this._getConfig(t2), this._isAppended = false, this._element = null;
        }
        static get Default() {
          return tn;
        }
        static get DefaultType() {
          return en;
        }
        static get NAME() {
          return Gi;
        }
        show(t2) {
          if (!this._config.isVisible) return void Jt(t2);
          this._append();
          const e2 = this._getElement();
          this._config.isAnimated && Kt(e2), e2.classList.add(Ji), this._emulateAnimation(() => {
            Jt(t2);
          });
        }
        hide(t2) {
          this._config.isVisible ? (this._getElement().classList.remove(Ji), this._emulateAnimation(() => {
            this.dispose(), Jt(t2);
          })) : Jt(t2);
        }
        dispose() {
          this._isAppended && (ge.off(this._element, Zi), this._element.remove(), this._isAppended = false);
        }
        _getElement() {
          if (!this._element) {
            const t2 = document.createElement("div");
            t2.className = this._config.className, this._config.isAnimated && t2.classList.add("fade"), this._element = t2;
          }
          return this._element;
        }
        _configAfterMerge(t2) {
          return t2.rootElement = Wt(t2.rootElement), t2;
        }
        _append() {
          if (this._isAppended) return;
          const t2 = this._getElement();
          this._config.rootElement.append(t2), ge.on(t2, Zi, () => {
            Jt(this._config.clickCallback);
          }), this._isAppended = true;
        }
        _emulateAnimation(t2) {
          Zt(t2, this._getElement(), this._config.isAnimated);
        }
      }
      const sn = ".bs.focustrap", on = `focusin${sn}`, rn = `keydown.tab${sn}`, an = "backward", ln = { autofocus: true, trapElement: null }, cn = { autofocus: "boolean", trapElement: "element" };
      class hn extends we {
        constructor(t2) {
          super(), this._config = this._getConfig(t2), this._isActive = false, this._lastTabNavDirection = null;
        }
        static get Default() {
          return ln;
        }
        static get DefaultType() {
          return cn;
        }
        static get NAME() {
          return "focustrap";
        }
        activate() {
          this._isActive || (this._config.autofocus && this._config.trapElement.focus(), ge.off(document, sn), ge.on(document, on, (t2) => this._handleFocusin(t2)), ge.on(document, rn, (t2) => this._handleKeydown(t2)), this._isActive = true);
        }
        deactivate() {
          this._isActive && (this._isActive = false, ge.off(document, sn));
        }
        _handleFocusin(t2) {
          const { trapElement: e2 } = this._config;
          if (t2.target === document || t2.target === e2 || e2.contains(t2.target)) return;
          const i2 = Te.focusableChildren(e2);
          0 === i2.length ? e2.focus() : this._lastTabNavDirection === an ? i2[i2.length - 1].focus() : i2[0].focus();
        }
        _handleKeydown(t2) {
          "Tab" === t2.key && (this._lastTabNavDirection = t2.shiftKey ? an : "forward");
        }
      }
      const un = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", dn = ".sticky-top", fn = "padding-right", pn = "margin-right";
      class mn {
        constructor() {
          this._element = document.body;
        }
        getWidth() {
          const t2 = document.documentElement.clientWidth;
          return Math.abs(window.innerWidth - t2);
        }
        hide() {
          const t2 = this.getWidth();
          this._disableOverFlow(), this._setElementAttributes(this._element, fn, (e2) => e2 + t2), this._setElementAttributes(un, fn, (e2) => e2 + t2), this._setElementAttributes(dn, pn, (e2) => e2 - t2);
        }
        reset() {
          this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, fn), this._resetElementAttributes(un, fn), this._resetElementAttributes(dn, pn);
        }
        isOverflowing() {
          return this.getWidth() > 0;
        }
        _disableOverFlow() {
          this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
        }
        _setElementAttributes(t2, e2, i2) {
          const n2 = this.getWidth();
          this._applyManipulationCallback(t2, (t3) => {
            if (t3 !== this._element && window.innerWidth > t3.clientWidth + n2) return;
            this._saveInitialAttribute(t3, e2);
            const s2 = window.getComputedStyle(t3).getPropertyValue(e2);
            t3.style.setProperty(e2, `${i2(Number.parseFloat(s2))}px`);
          });
        }
        _saveInitialAttribute(t2, e2) {
          const i2 = t2.style.getPropertyValue(e2);
          i2 && ye.setDataAttribute(t2, e2, i2);
        }
        _resetElementAttributes(t2, e2) {
          this._applyManipulationCallback(t2, (t3) => {
            const i2 = ye.getDataAttribute(t3, e2);
            null !== i2 ? (ye.removeDataAttribute(t3, e2), t3.style.setProperty(e2, i2)) : t3.style.removeProperty(e2);
          });
        }
        _applyManipulationCallback(t2, e2) {
          if (Bt(t2)) e2(t2);
          else for (const i2 of Te.find(t2, this._element)) e2(i2);
        }
      }
      const gn = ".bs.modal", _n = `hide${gn}`, bn = `hidePrevented${gn}`, vn = `hidden${gn}`, yn = `show${gn}`, wn = `shown${gn}`, An = `resize${gn}`, En = `click.dismiss${gn}`, Tn = `mousedown.dismiss${gn}`, Cn = `keydown.dismiss${gn}`, On = `click${gn}.data-api`, xn = "modal-open", kn = "show", Sn = "modal-static", Ln = { backdrop: true, focus: true, keyboard: true }, $n = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" };
      class Dn extends Ae {
        constructor(t2, e2) {
          super(t2, e2), this._dialog = Te.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = false, this._isTransitioning = false, this._scrollBar = new mn(), this._addEventListeners();
        }
        static get Default() {
          return Ln;
        }
        static get DefaultType() {
          return $n;
        }
        static get NAME() {
          return "modal";
        }
        toggle(t2) {
          return this._isShown ? this.hide() : this.show(t2);
        }
        show(t2) {
          this._isShown || this._isTransitioning || ge.trigger(this._element, yn, { relatedTarget: t2 }).defaultPrevented || (this._isShown = true, this._isTransitioning = true, this._scrollBar.hide(), document.body.classList.add(xn), this._adjustDialog(), this._backdrop.show(() => this._showElement(t2)));
        }
        hide() {
          this._isShown && !this._isTransitioning && (ge.trigger(this._element, _n).defaultPrevented || (this._isShown = false, this._isTransitioning = true, this._focustrap.deactivate(), this._element.classList.remove(kn), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())));
        }
        dispose() {
          ge.off(window, gn), ge.off(this._dialog, gn), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        handleUpdate() {
          this._adjustDialog();
        }
        _initializeBackDrop() {
          return new nn({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() });
        }
        _initializeFocusTrap() {
          return new hn({ trapElement: this._element });
        }
        _showElement(t2) {
          document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
          const e2 = Te.findOne(".modal-body", this._dialog);
          e2 && (e2.scrollTop = 0), Kt(this._element), this._element.classList.add(kn), this._queueCallback(() => {
            this._config.focus && this._focustrap.activate(), this._isTransitioning = false, ge.trigger(this._element, wn, { relatedTarget: t2 });
          }, this._dialog, this._isAnimated());
        }
        _addEventListeners() {
          ge.on(this._element, Cn, (t2) => {
            "Escape" === t2.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
          }), ge.on(window, An, () => {
            this._isShown && !this._isTransitioning && this._adjustDialog();
          }), ge.on(this._element, Tn, (t2) => {
            ge.one(this._element, En, (e2) => {
              this._element === t2.target && this._element === e2.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
            });
          });
        }
        _hideModal() {
          this._element.style.display = "none", this._element.setAttribute("aria-hidden", true), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = false, this._backdrop.hide(() => {
            document.body.classList.remove(xn), this._resetAdjustments(), this._scrollBar.reset(), ge.trigger(this._element, vn);
          });
        }
        _isAnimated() {
          return this._element.classList.contains("fade");
        }
        _triggerBackdropTransition() {
          if (ge.trigger(this._element, bn).defaultPrevented) return;
          const t2 = this._element.scrollHeight > document.documentElement.clientHeight, e2 = this._element.style.overflowY;
          "hidden" === e2 || this._element.classList.contains(Sn) || (t2 || (this._element.style.overflowY = "hidden"), this._element.classList.add(Sn), this._queueCallback(() => {
            this._element.classList.remove(Sn), this._queueCallback(() => {
              this._element.style.overflowY = e2;
            }, this._dialog);
          }, this._dialog), this._element.focus());
        }
        _adjustDialog() {
          const t2 = this._element.scrollHeight > document.documentElement.clientHeight, e2 = this._scrollBar.getWidth(), i2 = e2 > 0;
          if (i2 && !t2) {
            const t3 = Yt() ? "paddingLeft" : "paddingRight";
            this._element.style[t3] = `${e2}px`;
          }
          if (!i2 && t2) {
            const t3 = Yt() ? "paddingRight" : "paddingLeft";
            this._element.style[t3] = `${e2}px`;
          }
        }
        _resetAdjustments() {
          this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
        }
        static jQueryInterface(t2, e2) {
          return this.each(function() {
            const i2 = Dn.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === i2[t2]) throw new TypeError(`No method named "${t2}"`);
              i2[t2](e2);
            }
          });
        }
      }
      ge.on(document, On, '[data-bs-toggle="modal"]', function(t2) {
        const e2 = Te.getElementFromSelector(this);
        ["A", "AREA"].includes(this.tagName) && t2.preventDefault(), ge.one(e2, yn, (t3) => {
          t3.defaultPrevented || ge.one(e2, vn, () => {
            qt(this) && this.focus();
          });
        });
        const i2 = Te.findOne(".modal.show");
        i2 && Dn.getInstance(i2).hide(), Dn.getOrCreateInstance(e2).toggle(this);
      }), Ce(Dn), Gt(Dn);
      const In = ".bs.offcanvas", Pn = ".data-api", Nn = `load${In}${Pn}`, Mn = "show", jn = "showing", Fn = "hiding", Hn = ".offcanvas.show", zn = `show${In}`, Bn = `shown${In}`, Wn = `hide${In}`, qn = `hidePrevented${In}`, Rn = `hidden${In}`, Vn = `resize${In}`, Un = `click${In}${Pn}`, Kn = `keydown.dismiss${In}`, Qn = { backdrop: true, keyboard: true, scroll: false }, Xn = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" };
      class Yn extends Ae {
        constructor(t2, e2) {
          super(t2, e2), this._isShown = false, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
        }
        static get Default() {
          return Qn;
        }
        static get DefaultType() {
          return Xn;
        }
        static get NAME() {
          return "offcanvas";
        }
        toggle(t2) {
          return this._isShown ? this.hide() : this.show(t2);
        }
        show(t2) {
          this._isShown || ge.trigger(this._element, zn, { relatedTarget: t2 }).defaultPrevented || (this._isShown = true, this._backdrop.show(), this._config.scroll || new mn().hide(), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.classList.add(jn), this._queueCallback(() => {
            this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(Mn), this._element.classList.remove(jn), ge.trigger(this._element, Bn, { relatedTarget: t2 });
          }, this._element, true));
        }
        hide() {
          this._isShown && (ge.trigger(this._element, Wn).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = false, this._element.classList.add(Fn), this._backdrop.hide(), this._queueCallback(() => {
            this._element.classList.remove(Mn, Fn), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new mn().reset(), ge.trigger(this._element, Rn);
          }, this._element, true)));
        }
        dispose() {
          this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        _initializeBackDrop() {
          const t2 = Boolean(this._config.backdrop);
          return new nn({ className: "offcanvas-backdrop", isVisible: t2, isAnimated: true, rootElement: this._element.parentNode, clickCallback: t2 ? () => {
            "static" !== this._config.backdrop ? this.hide() : ge.trigger(this._element, qn);
          } : null });
        }
        _initializeFocusTrap() {
          return new hn({ trapElement: this._element });
        }
        _addEventListeners() {
          ge.on(this._element, Kn, (t2) => {
            "Escape" === t2.key && (this._config.keyboard ? this.hide() : ge.trigger(this._element, qn));
          });
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = Yn.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2] || t2.startsWith("_") || "constructor" === t2) throw new TypeError(`No method named "${t2}"`);
              e2[t2](this);
            }
          });
        }
      }
      ge.on(document, Un, '[data-bs-toggle="offcanvas"]', function(t2) {
        const e2 = Te.getElementFromSelector(this);
        if (["A", "AREA"].includes(this.tagName) && t2.preventDefault(), Rt(this)) return;
        ge.one(e2, Rn, () => {
          qt(this) && this.focus();
        });
        const i2 = Te.findOne(Hn);
        i2 && i2 !== e2 && Yn.getInstance(i2).hide(), Yn.getOrCreateInstance(e2).toggle(this);
      }), ge.on(window, Nn, () => {
        for (const t2 of Te.find(Hn)) Yn.getOrCreateInstance(t2).show();
      }), ge.on(window, Vn, () => {
        for (const t2 of Te.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t2).position && Yn.getOrCreateInstance(t2).hide();
      }), Ce(Yn), Gt(Yn);
      const Gn = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, Jn = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), Zn = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, ts = (t2, e2) => {
        const i2 = t2.nodeName.toLowerCase();
        return e2.includes(i2) ? !Jn.has(i2) || Boolean(Zn.test(t2.nodeValue)) : e2.filter((t3) => t3 instanceof RegExp).some((t3) => t3.test(i2));
      }, es = { allowList: Gn, content: {}, extraClass: "", html: false, sanitize: true, sanitizeFn: null, template: "<div></div>" }, is = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, ns = { entry: "(string|element|function|null)", selector: "(string|element)" };
      class ss extends we {
        constructor(t2) {
          super(), this._config = this._getConfig(t2);
        }
        static get Default() {
          return es;
        }
        static get DefaultType() {
          return is;
        }
        static get NAME() {
          return "TemplateFactory";
        }
        getContent() {
          return Object.values(this._config.content).map((t2) => this._resolvePossibleFunction(t2)).filter(Boolean);
        }
        hasContent() {
          return this.getContent().length > 0;
        }
        changeContent(t2) {
          return this._checkContent(t2), this._config.content = { ...this._config.content, ...t2 }, this;
        }
        toHtml() {
          const t2 = document.createElement("div");
          t2.innerHTML = this._maybeSanitize(this._config.template);
          for (const [e3, i3] of Object.entries(this._config.content)) this._setContent(t2, i3, e3);
          const e2 = t2.children[0], i2 = this._resolvePossibleFunction(this._config.extraClass);
          return i2 && e2.classList.add(...i2.split(" ")), e2;
        }
        _typeCheckConfig(t2) {
          super._typeCheckConfig(t2), this._checkContent(t2.content);
        }
        _checkContent(t2) {
          for (const [e2, i2] of Object.entries(t2)) super._typeCheckConfig({ selector: e2, entry: i2 }, ns);
        }
        _setContent(t2, e2, i2) {
          const n2 = Te.findOne(i2, t2);
          n2 && ((e2 = this._resolvePossibleFunction(e2)) ? Bt(e2) ? this._putElementInTemplate(Wt(e2), n2) : this._config.html ? n2.innerHTML = this._maybeSanitize(e2) : n2.textContent = e2 : n2.remove());
        }
        _maybeSanitize(t2) {
          return this._config.sanitize ? (function(t3, e2, i2) {
            if (!t3.length) return t3;
            if (i2 && "function" == typeof i2) return i2(t3);
            const n2 = new window.DOMParser().parseFromString(t3, "text/html"), s2 = [].concat(...n2.body.querySelectorAll("*"));
            for (const t4 of s2) {
              const i3 = t4.nodeName.toLowerCase();
              if (!Object.keys(e2).includes(i3)) {
                t4.remove();
                continue;
              }
              const n3 = [].concat(...t4.attributes), s3 = [].concat(e2["*"] || [], e2[i3] || []);
              for (const e3 of n3) ts(e3, s3) || t4.removeAttribute(e3.nodeName);
            }
            return n2.body.innerHTML;
          })(t2, this._config.allowList, this._config.sanitizeFn) : t2;
        }
        _resolvePossibleFunction(t2) {
          return Jt(t2, [void 0, this]);
        }
        _putElementInTemplate(t2, e2) {
          if (this._config.html) return e2.innerHTML = "", void e2.append(t2);
          e2.textContent = t2.textContent;
        }
      }
      const os = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), rs = "fade", as = "show", ls = ".tooltip-inner", cs = ".modal", hs = "hide.bs.modal", us = "hover", ds = "focus", fs = "click", ps = { AUTO: "auto", TOP: "top", RIGHT: Yt() ? "left" : "right", BOTTOM: "bottom", LEFT: Yt() ? "right" : "left" }, ms = { allowList: Gn, animation: true, boundary: "clippingParents", container: false, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: false, offset: [0, 6], placement: "top", popperConfig: null, sanitize: true, sanitizeFn: null, selector: false, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, gs = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" };
      class _s extends Ae {
        constructor(t2, e2) {
          if (void 0 === Pt) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");
          super(t2, e2), this._isEnabled = true, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
        }
        static get Default() {
          return ms;
        }
        static get DefaultType() {
          return gs;
        }
        static get NAME() {
          return "tooltip";
        }
        enable() {
          this._isEnabled = true;
        }
        disable() {
          this._isEnabled = false;
        }
        toggleEnabled() {
          this._isEnabled = !this._isEnabled;
        }
        toggle() {
          this._isEnabled && (this._isShown() ? this._leave() : this._enter());
        }
        dispose() {
          clearTimeout(this._timeout), ge.off(this._element.closest(cs), hs, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
        }
        show() {
          if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
          if (!this._isWithContent() || !this._isEnabled) return;
          const t2 = ge.trigger(this._element, this.constructor.eventName("show")), e2 = (Vt(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
          if (t2.defaultPrevented || !e2) return;
          this._disposePopper();
          const i2 = this._getTipElement();
          this._element.setAttribute("aria-describedby", i2.getAttribute("id"));
          const { container: n2 } = this._config;
          if (this._element.ownerDocument.documentElement.contains(this.tip) || (n2.append(i2), ge.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i2), i2.classList.add(as), "ontouchstart" in document.documentElement) for (const t3 of [].concat(...document.body.children)) ge.on(t3, "mouseover", Ut);
          this._queueCallback(() => {
            ge.trigger(this._element, this.constructor.eventName("shown")), false === this._isHovered && this._leave(), this._isHovered = false;
          }, this.tip, this._isAnimated());
        }
        hide() {
          if (this._isShown() && !ge.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
            if (this._getTipElement().classList.remove(as), "ontouchstart" in document.documentElement) for (const t2 of [].concat(...document.body.children)) ge.off(t2, "mouseover", Ut);
            this._activeTrigger[fs] = false, this._activeTrigger[ds] = false, this._activeTrigger[us] = false, this._isHovered = null, this._queueCallback(() => {
              this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), ge.trigger(this._element, this.constructor.eventName("hidden")));
            }, this.tip, this._isAnimated());
          }
        }
        update() {
          this._popper && this._popper.update();
        }
        _isWithContent() {
          return Boolean(this._getTitle());
        }
        _getTipElement() {
          return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
        }
        _createTipElement(t2) {
          const e2 = this._getTemplateFactory(t2).toHtml();
          if (!e2) return null;
          e2.classList.remove(rs, as), e2.classList.add(`bs-${this.constructor.NAME}-auto`);
          const i2 = ((t3) => {
            do {
              t3 += Math.floor(1e6 * Math.random());
            } while (document.getElementById(t3));
            return t3;
          })(this.constructor.NAME).toString();
          return e2.setAttribute("id", i2), this._isAnimated() && e2.classList.add(rs), e2;
        }
        setContent(t2) {
          this._newContent = t2, this._isShown() && (this._disposePopper(), this.show());
        }
        _getTemplateFactory(t2) {
          return this._templateFactory ? this._templateFactory.changeContent(t2) : this._templateFactory = new ss({ ...this._config, content: t2, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory;
        }
        _getContentForTemplate() {
          return { [ls]: this._getTitle() };
        }
        _getTitle() {
          return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
        }
        _initializeOnDelegatedTarget(t2) {
          return this.constructor.getOrCreateInstance(t2.delegateTarget, this._getDelegateConfig());
        }
        _isAnimated() {
          return this._config.animation || this.tip && this.tip.classList.contains(rs);
        }
        _isShown() {
          return this.tip && this.tip.classList.contains(as);
        }
        _createPopper(t2) {
          const e2 = Jt(this._config.placement, [this, t2, this._element]), i2 = ps[e2.toUpperCase()];
          return It(this._element, t2, this._getPopperConfig(i2));
        }
        _getOffset() {
          const { offset: t2 } = this._config;
          return "string" == typeof t2 ? t2.split(",").map((t3) => Number.parseInt(t3, 10)) : "function" == typeof t2 ? (e2) => t2(e2, this._element) : t2;
        }
        _resolvePossibleFunction(t2) {
          return Jt(t2, [this._element, this._element]);
        }
        _getPopperConfig(t2) {
          const e2 = { placement: t2, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: true, phase: "beforeMain", fn: (t3) => {
            this._getTipElement().setAttribute("data-popper-placement", t3.state.placement);
          } }] };
          return { ...e2, ...Jt(this._config.popperConfig, [void 0, e2]) };
        }
        _setListeners() {
          const t2 = this._config.trigger.split(" ");
          for (const e2 of t2) if ("click" === e2) ge.on(this._element, this.constructor.eventName("click"), this._config.selector, (t3) => {
            const e3 = this._initializeOnDelegatedTarget(t3);
            e3._activeTrigger[fs] = !(e3._isShown() && e3._activeTrigger[fs]), e3.toggle();
          });
          else if ("manual" !== e2) {
            const t3 = e2 === us ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), i2 = e2 === us ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
            ge.on(this._element, t3, this._config.selector, (t4) => {
              const e3 = this._initializeOnDelegatedTarget(t4);
              e3._activeTrigger["focusin" === t4.type ? ds : us] = true, e3._enter();
            }), ge.on(this._element, i2, this._config.selector, (t4) => {
              const e3 = this._initializeOnDelegatedTarget(t4);
              e3._activeTrigger["focusout" === t4.type ? ds : us] = e3._element.contains(t4.relatedTarget), e3._leave();
            });
          }
          this._hideModalHandler = () => {
            this._element && this.hide();
          }, ge.on(this._element.closest(cs), hs, this._hideModalHandler);
        }
        _fixTitle() {
          const t2 = this._element.getAttribute("title");
          t2 && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t2), this._element.setAttribute("data-bs-original-title", t2), this._element.removeAttribute("title"));
        }
        _enter() {
          this._isShown() || this._isHovered ? this._isHovered = true : (this._isHovered = true, this._setTimeout(() => {
            this._isHovered && this.show();
          }, this._config.delay.show));
        }
        _leave() {
          this._isWithActiveTrigger() || (this._isHovered = false, this._setTimeout(() => {
            this._isHovered || this.hide();
          }, this._config.delay.hide));
        }
        _setTimeout(t2, e2) {
          clearTimeout(this._timeout), this._timeout = setTimeout(t2, e2);
        }
        _isWithActiveTrigger() {
          return Object.values(this._activeTrigger).includes(true);
        }
        _getConfig(t2) {
          const e2 = ye.getDataAttributes(this._element);
          for (const t3 of Object.keys(e2)) os.has(t3) && delete e2[t3];
          return t2 = { ...e2, ..."object" == typeof t2 && t2 ? t2 : {} }, t2 = this._mergeConfigObj(t2), t2 = this._configAfterMerge(t2), this._typeCheckConfig(t2), t2;
        }
        _configAfterMerge(t2) {
          return t2.container = false === t2.container ? document.body : Wt(t2.container), "number" == typeof t2.delay && (t2.delay = { show: t2.delay, hide: t2.delay }), "number" == typeof t2.title && (t2.title = t2.title.toString()), "number" == typeof t2.content && (t2.content = t2.content.toString()), t2;
        }
        _getDelegateConfig() {
          const t2 = {};
          for (const [e2, i2] of Object.entries(this._config)) this.constructor.Default[e2] !== i2 && (t2[e2] = i2);
          return t2.selector = false, t2.trigger = "manual", t2;
        }
        _disposePopper() {
          this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = _s.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2]) throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
      }
      Gt(_s);
      const bs = ".popover-header", vs = ".popover-body", ys = { ..._s.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, ws = { ..._s.DefaultType, content: "(null|string|element|function)" };
      class As extends _s {
        static get Default() {
          return ys;
        }
        static get DefaultType() {
          return ws;
        }
        static get NAME() {
          return "popover";
        }
        _isWithContent() {
          return this._getTitle() || this._getContent();
        }
        _getContentForTemplate() {
          return { [bs]: this._getTitle(), [vs]: this._getContent() };
        }
        _getContent() {
          return this._resolvePossibleFunction(this._config.content);
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = As.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2]) throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
      }
      Gt(As);
      const Es = ".bs.scrollspy", Ts = `activate${Es}`, Cs = `click${Es}`, Os = `load${Es}.data-api`, xs = "active", ks = "[href]", Ss = ".nav-link", Ls = `${Ss}, .nav-item > ${Ss}, .list-group-item`, $s = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: false, target: null, threshold: [0.1, 0.5, 1] }, Ds = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" };
      class Is extends Ae {
        constructor(t2, e2) {
          super(t2, e2), this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map(), this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh();
        }
        static get Default() {
          return $s;
        }
        static get DefaultType() {
          return Ds;
        }
        static get NAME() {
          return "scrollspy";
        }
        refresh() {
          this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
          for (const t2 of this._observableSections.values()) this._observer.observe(t2);
        }
        dispose() {
          this._observer.disconnect(), super.dispose();
        }
        _configAfterMerge(t2) {
          return t2.target = Wt(t2.target) || document.body, t2.rootMargin = t2.offset ? `${t2.offset}px 0px -30%` : t2.rootMargin, "string" == typeof t2.threshold && (t2.threshold = t2.threshold.split(",").map((t3) => Number.parseFloat(t3))), t2;
        }
        _maybeEnableSmoothScroll() {
          this._config.smoothScroll && (ge.off(this._config.target, Cs), ge.on(this._config.target, Cs, ks, (t2) => {
            const e2 = this._observableSections.get(t2.target.hash);
            if (e2) {
              t2.preventDefault();
              const i2 = this._rootElement || window, n2 = e2.offsetTop - this._element.offsetTop;
              if (i2.scrollTo) return void i2.scrollTo({ top: n2, behavior: "smooth" });
              i2.scrollTop = n2;
            }
          }));
        }
        _getNewObserver() {
          const t2 = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin };
          return new IntersectionObserver((t3) => this._observerCallback(t3), t2);
        }
        _observerCallback(t2) {
          const e2 = (t3) => this._targetLinks.get(`#${t3.target.id}`), i2 = (t3) => {
            this._previousScrollData.visibleEntryTop = t3.target.offsetTop, this._process(e2(t3));
          }, n2 = (this._rootElement || document.documentElement).scrollTop, s2 = n2 >= this._previousScrollData.parentScrollTop;
          this._previousScrollData.parentScrollTop = n2;
          for (const o2 of t2) {
            if (!o2.isIntersecting) {
              this._activeTarget = null, this._clearActiveClass(e2(o2));
              continue;
            }
            const t3 = o2.target.offsetTop >= this._previousScrollData.visibleEntryTop;
            if (s2 && t3) {
              if (i2(o2), !n2) return;
            } else s2 || t3 || i2(o2);
          }
        }
        _initializeTargetsAndObservables() {
          this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map();
          const t2 = Te.find(ks, this._config.target);
          for (const e2 of t2) {
            if (!e2.hash || Rt(e2)) continue;
            const t3 = Te.findOne(decodeURI(e2.hash), this._element);
            qt(t3) && (this._targetLinks.set(decodeURI(e2.hash), e2), this._observableSections.set(e2.hash, t3));
          }
        }
        _process(t2) {
          this._activeTarget !== t2 && (this._clearActiveClass(this._config.target), this._activeTarget = t2, t2.classList.add(xs), this._activateParents(t2), ge.trigger(this._element, Ts, { relatedTarget: t2 }));
        }
        _activateParents(t2) {
          if (t2.classList.contains("dropdown-item")) Te.findOne(".dropdown-toggle", t2.closest(".dropdown")).classList.add(xs);
          else for (const e2 of Te.parents(t2, ".nav, .list-group")) for (const t3 of Te.prev(e2, Ls)) t3.classList.add(xs);
        }
        _clearActiveClass(t2) {
          t2.classList.remove(xs);
          const e2 = Te.find(`${ks}.${xs}`, t2);
          for (const t3 of e2) t3.classList.remove(xs);
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = Is.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2] || t2.startsWith("_") || "constructor" === t2) throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
      }
      ge.on(window, Os, () => {
        for (const t2 of Te.find('[data-bs-spy="scroll"]')) Is.getOrCreateInstance(t2);
      }), Gt(Is);
      const Ps = ".bs.tab", Ns = `hide${Ps}`, Ms = `hidden${Ps}`, js = `show${Ps}`, Fs = `shown${Ps}`, Hs = `click${Ps}`, zs = `keydown${Ps}`, Bs = `load${Ps}`, Ws = "ArrowLeft", qs = "ArrowRight", Rs = "ArrowUp", Vs = "ArrowDown", Us = "Home", Ks = "End", Qs = "active", Xs = "fade", Ys = "show", Gs = ".dropdown-toggle", Js = `:not(${Gs})`, Zs = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', to = `.nav-link${Js}, .list-group-item${Js}, [role="tab"]${Js}, ${Zs}`, eo = `.${Qs}[data-bs-toggle="tab"], .${Qs}[data-bs-toggle="pill"], .${Qs}[data-bs-toggle="list"]`;
      class io extends Ae {
        constructor(t2) {
          super(t2), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), ge.on(this._element, zs, (t3) => this._keydown(t3)));
        }
        static get NAME() {
          return "tab";
        }
        show() {
          const t2 = this._element;
          if (this._elemIsActive(t2)) return;
          const e2 = this._getActiveElem(), i2 = e2 ? ge.trigger(e2, Ns, { relatedTarget: t2 }) : null;
          ge.trigger(t2, js, { relatedTarget: e2 }).defaultPrevented || i2 && i2.defaultPrevented || (this._deactivate(e2, t2), this._activate(t2, e2));
        }
        _activate(t2, e2) {
          t2 && (t2.classList.add(Qs), this._activate(Te.getElementFromSelector(t2)), this._queueCallback(() => {
            "tab" === t2.getAttribute("role") ? (t2.removeAttribute("tabindex"), t2.setAttribute("aria-selected", true), this._toggleDropDown(t2, true), ge.trigger(t2, Fs, { relatedTarget: e2 })) : t2.classList.add(Ys);
          }, t2, t2.classList.contains(Xs)));
        }
        _deactivate(t2, e2) {
          t2 && (t2.classList.remove(Qs), t2.blur(), this._deactivate(Te.getElementFromSelector(t2)), this._queueCallback(() => {
            "tab" === t2.getAttribute("role") ? (t2.setAttribute("aria-selected", false), t2.setAttribute("tabindex", "-1"), this._toggleDropDown(t2, false), ge.trigger(t2, Ms, { relatedTarget: e2 })) : t2.classList.remove(Ys);
          }, t2, t2.classList.contains(Xs)));
        }
        _keydown(t2) {
          if (![Ws, qs, Rs, Vs, Us, Ks].includes(t2.key)) return;
          t2.stopPropagation(), t2.preventDefault();
          const e2 = this._getChildren().filter((t3) => !Rt(t3));
          let i2;
          if ([Us, Ks].includes(t2.key)) i2 = e2[t2.key === Us ? 0 : e2.length - 1];
          else {
            const n2 = [qs, Vs].includes(t2.key);
            i2 = te(e2, t2.target, n2, true);
          }
          i2 && (i2.focus({ preventScroll: true }), io.getOrCreateInstance(i2).show());
        }
        _getChildren() {
          return Te.find(to, this._parent);
        }
        _getActiveElem() {
          return this._getChildren().find((t2) => this._elemIsActive(t2)) || null;
        }
        _setInitialAttributes(t2, e2) {
          this._setAttributeIfNotExists(t2, "role", "tablist");
          for (const t3 of e2) this._setInitialAttributesOnChild(t3);
        }
        _setInitialAttributesOnChild(t2) {
          t2 = this._getInnerElement(t2);
          const e2 = this._elemIsActive(t2), i2 = this._getOuterElement(t2);
          t2.setAttribute("aria-selected", e2), i2 !== t2 && this._setAttributeIfNotExists(i2, "role", "presentation"), e2 || t2.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t2, "role", "tab"), this._setInitialAttributesOnTargetPanel(t2);
        }
        _setInitialAttributesOnTargetPanel(t2) {
          const e2 = Te.getElementFromSelector(t2);
          e2 && (this._setAttributeIfNotExists(e2, "role", "tabpanel"), t2.id && this._setAttributeIfNotExists(e2, "aria-labelledby", `${t2.id}`));
        }
        _toggleDropDown(t2, e2) {
          const i2 = this._getOuterElement(t2);
          if (!i2.classList.contains("dropdown")) return;
          const n2 = (t3, n3) => {
            const s2 = Te.findOne(t3, i2);
            s2 && s2.classList.toggle(n3, e2);
          };
          n2(Gs, Qs), n2(".dropdown-menu", Ys), i2.setAttribute("aria-expanded", e2);
        }
        _setAttributeIfNotExists(t2, e2, i2) {
          t2.hasAttribute(e2) || t2.setAttribute(e2, i2);
        }
        _elemIsActive(t2) {
          return t2.classList.contains(Qs);
        }
        _getInnerElement(t2) {
          return t2.matches(to) ? t2 : Te.findOne(to, t2);
        }
        _getOuterElement(t2) {
          return t2.closest(".nav-item, .list-group-item") || t2;
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = io.getOrCreateInstance(this);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2] || t2.startsWith("_") || "constructor" === t2) throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
      }
      ge.on(document, Hs, Zs, function(t2) {
        ["A", "AREA"].includes(this.tagName) && t2.preventDefault(), Rt(this) || io.getOrCreateInstance(this).show();
      }), ge.on(window, Bs, () => {
        for (const t2 of Te.find(eo)) io.getOrCreateInstance(t2);
      }), Gt(io);
      const no = ".bs.toast", so = `mouseover${no}`, oo = `mouseout${no}`, ro = `focusin${no}`, ao = `focusout${no}`, lo = `hide${no}`, co = `hidden${no}`, ho = `show${no}`, uo = `shown${no}`, fo = "hide", po = "show", mo = "showing", go = { animation: "boolean", autohide: "boolean", delay: "number" }, _o = { animation: true, autohide: true, delay: 5e3 };
      class bo extends Ae {
        constructor(t2, e2) {
          super(t2, e2), this._timeout = null, this._hasMouseInteraction = false, this._hasKeyboardInteraction = false, this._setListeners();
        }
        static get Default() {
          return _o;
        }
        static get DefaultType() {
          return go;
        }
        static get NAME() {
          return "toast";
        }
        show() {
          ge.trigger(this._element, ho).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(fo), Kt(this._element), this._element.classList.add(po, mo), this._queueCallback(() => {
            this._element.classList.remove(mo), ge.trigger(this._element, uo), this._maybeScheduleHide();
          }, this._element, this._config.animation));
        }
        hide() {
          this.isShown() && (ge.trigger(this._element, lo).defaultPrevented || (this._element.classList.add(mo), this._queueCallback(() => {
            this._element.classList.add(fo), this._element.classList.remove(mo, po), ge.trigger(this._element, co);
          }, this._element, this._config.animation)));
        }
        dispose() {
          this._clearTimeout(), this.isShown() && this._element.classList.remove(po), super.dispose();
        }
        isShown() {
          return this._element.classList.contains(po);
        }
        _maybeScheduleHide() {
          this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
            this.hide();
          }, this._config.delay)));
        }
        _onInteraction(t2, e2) {
          switch (t2.type) {
            case "mouseover":
            case "mouseout":
              this._hasMouseInteraction = e2;
              break;
            case "focusin":
            case "focusout":
              this._hasKeyboardInteraction = e2;
          }
          if (e2) return void this._clearTimeout();
          const i2 = t2.relatedTarget;
          this._element === i2 || this._element.contains(i2) || this._maybeScheduleHide();
        }
        _setListeners() {
          ge.on(this._element, so, (t2) => this._onInteraction(t2, true)), ge.on(this._element, oo, (t2) => this._onInteraction(t2, false)), ge.on(this._element, ro, (t2) => this._onInteraction(t2, true)), ge.on(this._element, ao, (t2) => this._onInteraction(t2, false));
        }
        _clearTimeout() {
          clearTimeout(this._timeout), this._timeout = null;
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = bo.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2]) throw new TypeError(`No method named "${t2}"`);
              e2[t2](this);
            }
          });
        }
      }
      Ce(bo), Gt(bo);
      const vo = Object.freeze(Object.defineProperty({ __proto__: null, Alert: Se, Button: $e, Carousel: ui, Collapse: Ci, Dropdown: Yi, Modal: Dn, Offcanvas: Yn, Popover: As, ScrollSpy: Is, Tab: io, Toast: bo, Tooltip: _s }, Symbol.toStringTag, { value: "Module" }));
      [].slice.call(document.querySelectorAll('[data-bs-toggle="dropdown"]')).map(function(t2) {
        let e2 = { boundary: "viewport" === t2.getAttribute("data-bs-boundary") ? document.querySelector(".btn") : "clippingParents" };
        return new Yi(t2, e2);
      }), [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')).map(function(t2) {
        let e2 = { delay: { show: 50, hide: 50 }, html: "true" === t2.getAttribute("data-bs-html"), placement: t2.getAttribute("data-bs-placement") ?? "auto" };
        return new _s(t2, e2);
      }), [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]')).map(function(t2) {
        let e2 = { delay: { show: 50, hide: 50 }, html: "true" === t2.getAttribute("data-bs-html"), placement: t2.getAttribute("data-bs-placement") ?? "auto" };
        return new As(t2, e2);
      }), [].slice.call(document.querySelectorAll('[data-bs-toggle="switch-icon"]')).map(function(t2) {
        t2.addEventListener("click", (e2) => {
          e2.stopPropagation(), t2.classList.toggle("active");
        });
      }), (() => {
        const t2 = window.location.hash;
        t2 && [].slice.call(document.querySelectorAll('[data-bs-toggle="tab"]')).filter((e2) => e2.hash === t2).map((t3) => {
          new io(t3).show();
        });
      })(), [].slice.call(document.querySelectorAll('[data-bs-toggle="toast"]')).map(function(t2) {
        if (!t2.hasAttribute("data-bs-target")) return;
        const e2 = new bo(t2.getAttribute("data-bs-target"));
        t2.addEventListener("click", () => {
          e2.show();
        });
      });
      const yo = "tblr-", wo = (t2, e2) => {
        const i2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t2);
        return i2 ? `rgba(${parseInt(i2[1], 16)}, ${parseInt(i2[2], 16)}, ${parseInt(i2[3], 16)}, ${e2})` : null;
      }, Ao = Object.freeze(Object.defineProperty({ __proto__: null, getColor: (t2, e2 = 1) => {
        const i2 = getComputedStyle(document.body).getPropertyValue(`--${yo}${t2}`).trim();
        return 1 !== e2 ? wo(i2, e2) : i2;
      }, hexToRgba: wo, prefix: yo }, Symbol.toStringTag, { value: "Module" }));
      t.Alert = Se, t.Button = $e, t.Carousel = ui, t.Collapse = Ci, t.Dropdown = Yi, t.Modal = Dn, t.Offcanvas = Yn, t.Popover = As, t.ScrollSpy = Is, t.Tab = io, t.Toast = bo, t.Tooltip = _s, t.bootstrap = vo, t.tabler = Ao, Object.defineProperty(t, Symbol.toStringTag, { value: "Module" });
    });
  }
});
export default require_tabler_min();
/*! Bundled license information:

@tabler/core/dist/js/tabler.min.js:
  (*!
   * Tabler v1.4.0 (https://tabler.io)
   * Copyright 2018-2025 The Tabler Authors
   * Copyright 2018-2025 codecalm.net Pawe Kuna
   * Licensed under MIT (https://github.com/tabler/tabler/blob/master/LICENSE)
   *)
  (*!
  	  * Bootstrap v5.3.7 (https://getbootstrap.com/)
  	  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  	  *)
*/
//# sourceMappingURL=@tabler_core_dist_js_tabler__min__js.js.map
